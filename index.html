<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Assistant</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            height: 100vh;
            display: flex;
        }
        
        .sidebar {
            width: 80px;
            background: white;
            border-right: 1px solid #e2e8f0;
            padding: 20px 10px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .sidebar.collapsed {
            width: 0;
            padding: 0;
            border-right: none;
            overflow: hidden;
        }
        
        .logo {
            display: none;
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            margin-bottom: 8px;
            color: #64748b;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .nav-item:hover {
            background: #f1f5f9;
            color: #3b82f6;
        }
        
        .nav-item.active {
            background: #f0f9ff;
            color: #3b82f6;
        }
        
        .panel-container {
            width: 33.33%;
            min-width: 300px;
            max-width: 500px;
            background: white;
            border-right: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            position: relative;
        }
        
        /* Ensure good proportions on very wide screens */
        @media (min-width: 1920px) {
            .panel-container {
                width: 30%;
                max-width: 600px;
            }
            .source-viewer {
                width: 30%;
                max-width: 600px;
            }
        }
        
        .panel-container.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            border-right: none;
            overflow: hidden;
        }
        
        .panel {
            display: none;
            height: 100vh;
            flex-direction: column;
        }
        
        .panel.active {
            display: flex;
        }
        
        .panel-header {
            padding: 20px;
            border-bottom: 1px solid #f1f5f9;
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .writing-area {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
            min-height: 0; /* Allow flex item to shrink */
            height: 100vh; /* Ensure full height */
        }
        
        .writing-header {
            padding: 20px;
            border-bottom: 1px solid #f1f5f9;
            transition: padding-left 0.3s ease;
        }
        
        .writing-header.sidebar-collapsed {
            padding-left: 80px;
        }
        
        .writing-title {
            font-size: 24px;
            font-weight: 600;
            color: #1e293b;
            border: none;
            outline: none;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .writing-meta {
            color: #64748b;
            font-size: 14px;
        }
        
        .writing-content {
            flex: 1;
            padding: 20px;
            min-height: 0; /* Allow flex item to shrink */
            display: flex;
            flex-direction: column;
        }
        
        .editor {
            width: 100%;
            flex: 1;
            border: none;
            outline: none;
            font-size: 16px;
            line-height: 1.6;
            color: #334155;
            resize: none;
            font-family: Georgia, 'Times New Roman', serif;
            min-height: 400px; /* Ensure minimum height */
        }
        
        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            margin-bottom: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .search-input.notes-search {
            min-height: 90px;
            max-height: 300px;
            resize: none;
            line-height: 1.5;
            overflow-y: auto;
            transition: height 0.2s ease;
        }
        
        .search-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .btn:hover:not(:disabled) {
            background: #2563eb;
        }
        
        .btn:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }
        
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #9ca3af;
        }
        
        .empty-icon {
            width: 32px;
            height: 32px;
            margin: 0 auto 12px;
            opacity: 0.4;
            color: #9ca3af;
        }
        
        .empty-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
        }
        
        .empty-description {
            font-size: 14px;
        }
        
        .file-drop-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .file-drop-area:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }
        
        .file-drop-area.dragover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .source-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .source-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .source-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .source-icon {
            width: 32px;
            height: 32px;
            background: #f1f5f9;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .source-info {
            flex: 1;
        }

        .source-title {
            font-size: 14px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 2px;
        }

        .source-author {
            font-size: 12px;
            color: #64748b;
        }

        .status-badge {
            background: #10b981;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .status-badge.processing {
            background: #fbbf24;
        }

        .status-badge.error {
            background: #ef4444;
        }

        .source-action-btn.review {
            background: #3b82f6;
            color: white;
        }

        .source-action-btn.review:hover {
            background: #2563eb;
        }

        .source-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .source-action-btn {
            flex: 1;
            background: none;
            border: 1px solid #e2e8f0;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #64748b;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .source-action-btn:hover {
            background: #f1f5f9;
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .source-action-btn.delete {
            color: #ef4444;
            border-color: #fecaca;
        }

        .source-action-btn.delete:hover {
            background: #fef2f2;
            border-color: #ef4444;
        }

        /* Search mode toggle styles */
        .search-mode-toggle {
            margin: 12px 0;
            padding: 8px 0;
        }

        .search-mode-options {
            display: flex;
            gap: 16px;
        }

        .search-mode-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
        }

        .search-mode-option input[type="radio"] {
            margin: 0;
        }

        .search-mode-option input[type="radio"]:checked + span {
            color: #3b82f6;
            font-weight: 500;
        }

        /* Auto-search toggle styles */
        .auto-search-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding: 8px 0;
        }

        .auto-search-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #64748b;
            cursor: pointer;
        }

        .auto-search-toggle input[type="checkbox"] {
            margin: 0;
        }

        .auto-search-status {
            font-size: 12px;
            color: #10b981;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* New styles for note cards and filters */
        .notes-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .filter-select {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            color: #374151;
        }

        .filter-select:focus {
            border-color: #3b82f6;
            outline: none;
        }

        .note-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .note-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .note-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .note-meta {
            flex: 1;
        }

        .note-score {
            font-size: 12px;
            font-weight: 600;
            color: #059669;
            margin-bottom: 4px;
        }

        .note-source {
            font-size: 12px;
            color: #64748b;
        }

        .note-categories {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }


        .note-actions {
            display: flex;
            gap: 8px;
        }

        .note-action-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: #f8fafc;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            transition: all 0.2s ease;
        }

        .note-action-btn:hover {
            background: #e2e8f0;
            color: #3b82f6;
        }

        .note-action-btn.saved {
            background: #dcfce7;
            color: #059669;
        }

        .note-action-btn.delete-btn {
            color: #64748b;
        }

        .note-action-btn.delete-btn:hover {
            background: #fef2f2;
            color: #dc2626;
        }

        .note-action-btn.delete-btn.confirming {
            background: #fef2f2;
            color: #dc2626;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .note-content {
            font-size: 14px;
            line-height: 1.5;
            color: #374151;
        }

        .search-highlight {
            background-color: #fef3c7;
            color: #92400e;
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: 600;
        }

        .icon {
            width: 20px;
            height: 20px;
        }

        /* Load more button styles */
        .load-more-container {
            text-align: center;
            padding: 20px 0;
            border-top: 1px solid #f1f5f9;
            margin-top: 16px;
        }

        .load-more-btn {
            background: #f8fafc;
            color: #64748b;
            border: 1px solid #e2e8f0;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .load-more-btn:hover {
            background: #f1f5f9;
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .load-more-btn:disabled {
            background: #f8fafc;
            color: #94a3b8;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Toggle button styles */
        .toggle-btn {
            position: absolute;
            top: 20px;
            right: -12px;
            width: 24px;
            height: 24px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .toggle-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }
        
        .toggle-btn svg {
            width: 12px;
            height: 12px;
            color: #64748b;
        }
        
        .toggle-btn:hover svg {
            color: #3b82f6;
        }
        
        .sidebar .toggle-btn {
            right: -12px;
        }
        
        .panel-container .toggle-btn {
            right: -12px;
        }
        
        /* Hamburger menu for collapsed sidebar */
        .hamburger-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }
        
        .hamburger-menu:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }
        
        .hamburger-menu svg {
            width: 20px;
            height: 20px;
            color: #64748b;
        }
        
        .hamburger-menu:hover svg {
            color: #3b82f6;
        }
        
        .hamburger-menu.show {
            display: flex;
        }
        
        /* Source Viewer Styles */
        .source-viewer {
            width: 33.33%;
            min-width: 300px;
            max-width: 500px;
            background: white;
            border-right: 1px solid #e2e8f0;
            display: none;
            flex-direction: column;
            position: relative;
        }
        
        .source-viewer.active {
            display: flex;
        }
        
        .source-viewer.collapsed {
            width: 0;
            border-right: none;
            overflow: hidden;
        }
        
        .source-viewer-header {
            padding: 20px;
            border-bottom: 1px solid #f1f5f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .source-viewer-title {
            font-size: 16px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .source-viewer-close {
            width: 24px;
            height: 24px;
            border: none;
            background: none;
            cursor: pointer;
            color: #64748b;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .source-viewer-close:hover {
            background: #f1f5f9;
            color: #374151;
        }
        
        .source-viewer-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .source-viewer-content h1,
        .source-viewer-content h2,
        .source-viewer-content h3 {
            color: #1e293b;
            margin-top: 24px;
            margin-bottom: 12px;
        }
        
        .source-viewer-content h1 {
            font-size: 24px;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
        }
        
        .source-viewer-content h2 {
            font-size: 20px;
        }
        
        .source-viewer-content h3 {
            font-size: 18px;
        }
        
        .source-viewer-content p {
            margin-bottom: 16px;
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            padding: 20px 20px 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 20px;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #1e293b;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #64748b;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            color: #1e293b;
        }
        
        .modal-body {
            padding: 0 20px 20px 20px;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: #f1f5f9;
            color: #64748b;
            border: 1px solid #e2e8f0;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-secondary:hover {
            background: #e2e8f0;
            color: #475569;
        }
        
        .chunk-marker {
            position: relative;
        }
        
        .chunk-marker::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            width: 4px;
            height: 100%;
            background: #3b82f6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .chunk-marker.highlighted::before {
            opacity: 1;
        }
        
        .chunk-marker.highlighted {
            background: #f0f9ff;
            padding: 8px;
            border-radius: 4px;
            margin: 4px 0;
        }

        /* Review Interface Styles */
        .review-interface {
            display: none;
            flex-direction: column;
            height: 100%;
            flex: 1;
            background: #f8fafc;
        }

        .review-interface.active {
            display: flex;
        }

        .review-header {
            background: white;
            border-bottom: 1px solid #e2e8f0;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .review-title {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            margin: 0;
        }

        .review-actions {
            display: flex;
            gap: 12px;
        }

        .review-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .review-btn.primary {
            background: #10b981;
            color: white;
        }

        .review-btn.primary:hover {
            background: #059669;
        }

        .review-btn.secondary {
            background: #6b7280;
            color: white;
        }

        .review-btn.secondary:hover {
            background: #4b5563;
        }

        .review-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .chunk-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 16px;
            padding: 16px;
            position: relative;
        }

        .chunk-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.1);
        }

        .chunk-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .chunk-index {
            font-size: 12px;
            color: #6b7280;
            font-weight: 500;
        }

        .chunk-actions {
            display: flex;
            gap: 8px;
        }

        .chunk-action-btn {
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chunk-action-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .chunk-action-btn.danger {
            color: #dc2626;
            border-color: #fca5a5;
        }

        .chunk-action-btn.danger:hover {
            background: #fef2f2;
            border-color: #f87171;
        }
        .heading-level-select {
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .heading-level-select:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .chunk-card.heading {
            border-left: 4px solid #3b82f6;
            background: #f0f9ff;
        }
        
        .chunk-card.heading .chunk-content {
            font-weight: 600;
            font-size: 16px;
            color: #1e40af;
        }
        
        .chunk-card.heading .chunk-index {
            color: #3b82f6;
            font-weight: 600;
        }

        .chunk-content {
            min-height: 100px;
            height: auto;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 14px;
            line-height: 1.5;
            outline: none;
            resize: none;
            width: 100%;
            box-sizing: border-box;
            overflow: hidden;
        }

        .chunk-content:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .chunk-structure {
            font-size: 12px;
            color: #6b7280;
            margin-top: 8px;
        }
        
        .structure-path-input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 12px;
            color: #6b7280;
            background: #f9fafb;
            outline: none;
            transition: all 0.2s;
        }
        
        .structure-path-input:focus {
            border-color: #3b82f6;
            background: white;
            color: #374151;
        }
        
        .structure-path-input::placeholder {
            color: #9ca3af;
        }
        
        .saved-notes-section {
            margin: 16px 0;
        }
        
        .saved-notes-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            color: #475569;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .saved-notes-btn:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }
        
        .saved-notes-btn .icon {
            width: 16px;
            height: 16px;
        }
        
        .custom-multiselect {
            position: relative;
            margin: 16px 0;
        }
        
        .multiselect-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .multiselect-trigger:hover {
            border-color: #9ca3af;
        }
        
        .multiselect-selected {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .multiselect-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: #f3f4f6;
            border-radius: 4px;
            font-size: 12px;
            color: #374151;
        }
        
        .multiselect-tag .remove {
            cursor: pointer;
            color: #6b7280;
        }
        
        .multiselect-tag .remove:hover {
            color: #374151;
        }
        
        .multiselect-arrow {
            color: #6b7280;
            transition: transform 0.2s ease;
        }
        
        .multiselect-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 10;
            margin-top: 4px;
        }
        
        .multiselect-search {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
        }
        
        .multiselect-search input {
            width: 100%;
            padding: 4px 8px;
            border: none;
            outline: none;
            font-size: 14px;
        }
        
        .multiselect-options {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .multiselect-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .multiselect-option:hover {
            background: #f9fafb;
        }
        
        .multiselect-option input[type="checkbox"] {
            margin-right: 8px;
        }
        
        .multiselect-option label {
            cursor: pointer;
            font-size: 14px;
            color: #374151;
        }

        .review-stats {
            background: #f1f5f9;
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #475569;
        }

        .empty-review {
            text-align: center;
            padding: 60px 20px;
            color: #6b7280;
        }

        .empty-review-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            opacity: 0.5;
        }
        
        /* Project card styles */
        .project-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .project-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .project-card.active {
            background: #f0f9ff;
            border-color: #3b82f6;
        }
    </style>
</head>
<body>
    <div class="sidebar" id="sidebar">
        
        <div class="nav-item active" onclick="switchToPanel('projects', this)" title="Projects">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
            </svg>
        </div>
        <div class="nav-item" onclick="switchToPanel('library', this)" title="Library">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
            </svg>
        </div>
        <div class="nav-item" onclick="switchToPanel('notes', this)" title="Notes">
            <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
        </div>
    </div>
    
    <div class="panel-container" id="panel-container">
        <button class="toggle-btn" onclick="togglePanel()" title="Collapse panel">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
        </button>
        
        <!-- Projects Panel -->
        <div class="panel active" id="projects-panel">
            <div class="panel-header">
                <div class="panel-title">Projects</div>
            </div>
            <div class="panel-content">
                <input type="text" class="search-input" placeholder="Search projects..." id="project-search">
                <button class="btn" onclick="showCreateProjectModal()">+ New Project</button>
                
                <div style="margin-top: 20px;" id="projects-container">
                    <!-- Projects will be dynamically loaded here -->
                </div>
            </div>
        </div>
        
        <!-- Library Panel -->
        <div class="panel" id="library-panel">
            <div class="panel-header">
                <div class="panel-title">Library</div>
            </div>
            <div class="panel-content">
                <input type="text" class="search-input" placeholder="Search sources..." id="library-search">
                <button class="btn" onclick="showUploadInterface()">+ Upload Source</button>
                
                <!-- Upload Form -->
                <div id="upload-form" style="display: none; margin-top: 20px; padding: 20px; border: 1px solid #e2e8f0; border-radius: 8px; background: #f8fafc;">
                    <h3 style="margin-bottom: 16px; font-size: 16px; font-weight: 600; color: #1e293b;">Upload New Source</h3>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #374151;">Title</label>
                        <input type="text" id="upload-title" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #374151;">Author (optional)</label>
                        <input type="text" id="upload-author" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                    </div>
                    
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #374151;">Choose File</label>
                        <div class="file-drop-area" onclick="document.getElementById('file-input').click()">
                            <input type="file" id="file-input" accept=".txt,.json,.pdf,.epub" style="display: none;">
                            <svg width="48" height="48" style="margin: 0 auto 12px; color: #9ca3af;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                            </svg>
                            <div style="font-size: 14px; color: #374151; margin-bottom: 4px;">
                                <strong>Click to upload</strong> or drag and drop
                            </div>
                            <div style="font-size: 12px; color: #6b7280;">
                                Supports: .txt, .json, .pdf, .epub files
                            </div>
                        </div>
                        <div id="selected-file" style="display: none; margin-top: 12px; padding: 8px; background: #f0f9ff; border-radius: 4px; font-size: 14px; color: #1e40af;"></div>
                    </div>
                    
                    <div style="display: flex; gap: 8px;">
                        <button class="btn" onclick="processUpload()" id="upload-btn" disabled>Upload & Process</button>
                        <button onclick="hideUploadInterface()" style="background: #f1f5f9; color: #64748b; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancel</button>
                    </div>
                    
                    <div id="upload-status" style="margin-top: 12px; font-size: 14px;"></div>
                </div>
                
                <div style="margin-top: 20px;" id="sources-list">
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                            </svg>
                        </div>
                        <div class="empty-title">No sources yet</div>
                        <div class="empty-description">Upload your first source to get started</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Notes Panel -->
        <div class="panel" id="notes-panel">
            <div class="panel-header">
                <div class="panel-title">Notes</div>
            </div>
            <div class="panel-content">
                <textarea class="search-input notes-search" placeholder="Search your sources with a detailed query or question" id="notes-search" oninput="console.log('Input event triggered'); performSearch(); autoResizeTextarea(this)" onkeydown="handleSearchKeydown(event)"></textarea>
                <button onclick="testSearch('grace of God')" style="margin-top: 10px; padding: 5px 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Test Search</button>
                <button onclick="console.log('Search mode:', searchMode, 'Auto-search:', autoSearchEnabled); console.log('Search input value:', document.getElementById('notes-search').value);" style="margin-top: 10px; padding: 5px 10px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">Debug State</button>
                
                <!-- Search Mode Toggle -->
                <div class="search-mode-toggle">
                    <div class="search-mode-options">
                        <label class="search-mode-option">
                            <input type="radio" name="search-mode" value="smart" checked onchange="toggleSearchMode()">
                            <span>Smart Search</span>
                        </label>
                        <label class="search-mode-option">
                            <input type="radio" name="search-mode" value="text" onchange="toggleSearchMode()">
                            <span>Text Search</span>
                        </label>
                    </div>
                </div>
                
                <!-- Auto-search Toggle (only shown for Smart Search) -->
                <div class="auto-search-toggle" id="auto-search-container">
                    <label>
                        <input type="checkbox" id="auto-search-toggle" checked onchange="toggleAutoSearch()">
                        <span>Auto-search</span>
                    </label>
                    <div id="auto-search-status" class="auto-search-status">
                        ✓ Auto-searching...
                    </div>
                </div>
                
                
                <!-- Filter Options -->
                <div class="saved-notes-section" style="margin: 16px 0;">
                    <button class="saved-notes-btn" onclick="openSavedNotes()" title="View all saved notes for this project">
                        <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z" />
                        </svg>
                        View Saved Notes
                    </button>
                </div>
                
                <div class="custom-multiselect" id="source-filter-container">
                    <div class="multiselect-trigger" onclick="toggleMultiselect()">
                        <div class="multiselect-selected" id="multiselect-selected">
                            <span class="placeholder">All Sources</span>
                        </div>
                        <div class="multiselect-arrow">▼</div>
                    </div>
                    <div class="multiselect-dropdown" id="multiselect-dropdown" style="display: none;">
                        <div class="multiselect-search">
                            <input type="text" id="multiselect-search" placeholder="Search sources..." onkeyup="filterMultiselectOptions()">
                        </div>
                        <div class="multiselect-options" id="multiselect-options">
                            <div class="multiselect-option" data-value="">
                                <input type="checkbox" id="option-all" onchange="toggleAllSources()">
                                <label for="option-all">All Sources</label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="notes-filters" style="margin-top: 8px;">
                    <select class="filter-select" id="project-filter" onchange="applyFilters()">
                        <option value="">All Notes</option>
                    </select>
                </div>
                
                <div id="notes-results">
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                            </svg>
                        </div>
                        <div class="empty-title">No notes yet</div>
                        <div class="empty-description">Search or start writing to see relevant notes</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Hamburger Menu (shown when sidebar is collapsed) -->
    <div class="hamburger-menu" id="hamburger-menu" onclick="expandSidebar()" title="Open menu">
        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </div>
    
    <!-- Source Details Modal -->
    <div id="source-details-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Source Details</h3>
                <button class="modal-close" onclick="hideSourceDetails()">&times;</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #374151;">Title</label>
                    <input type="text" id="edit-source-title" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 4px; font-size: 12px; font-weight: 600; color: #374151;">Author (optional)</label>
                    <input type="text" id="edit-source-author" style="width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button class="btn-secondary" onclick="hideSourceDetails()">Cancel</button>
                    <button class="btn-primary" onclick="saveSourceDetails()">Save Changes</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Source Notes Viewer -->
    <div class="source-viewer" id="source-viewer">
        <div class="source-viewer-header">
            <div class="source-viewer-title" id="source-viewer-title">Saved Project Notes</div>
            <button class="source-viewer-close" onclick="closeSourceViewer()" title="Close notes viewer">
                <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
            </button>
        </div>
        <div class="source-viewer-content" id="source-viewer-content">
            <div class="empty-state">
                <div class="empty-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                    </svg>
                </div>
                <div class="empty-title">No notes selected</div>
                <div class="empty-description">Click "Notes" on a source or "View note in context" on a note</div>
            </div>
        </div>
    </div>
    
    <!-- Review Interface -->
    <div class="review-interface" id="review-interface">
        <div class="review-header">
            <h2 class="review-title" id="review-title">AI Curation Status</h2>
            <div class="review-actions">
                <button class="review-btn secondary" onclick="closeReviewInterface()">Close</button>
                <button class="review-btn primary" onclick="completeReview()">Complete Processing</button>
            </div>
        </div>
        <div class="review-content" id="review-content">
            <div class="empty-review">
                <div class="empty-review-icon">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                    </svg>
                </div>
                <div class="empty-title">AI Curation Complete</div>
                <div class="empty-description">Your document has been processed by AI and is ready for search</div>
            </div>
        </div>
    </div>
    
    <!-- Writing Area -->
    <div class="writing-area">
        <div class="writing-header">
            <input type="text" class="writing-title" placeholder="Untitled Document" id="document-title">
            <div class="writing-meta">Draft • Last modified: Today</div>
        </div>
        <div class="writing-content">
            <textarea class="editor" placeholder="Start writing your research paper..." id="document-editor" oninput="handleEditorInput()"></textarea>
        </div>
    </div>

    <!-- Create Project Modal -->
    <div id="create-project-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
            <h3 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; color: #1e293b;">Create New Project</h3>
            <input type="text" id="new-project-title" placeholder="Project title..." style="width: 100%; padding: 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; margin-bottom: 16px;">
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button onclick="hideCreateProjectModal()" style="background: #f1f5f9; color: #64748b; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancel</button>
                <button onclick="createNewProject()" class="btn">Create Project</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-project-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw;">
            <h3 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; color: #1e293b;">Delete Project</h3>
            <p style="margin: 0 0 16px 0; color: #64748b;">Are you sure you want to delete "<span id="delete-project-name"></span>"? This action cannot be undone.</p>
            <div style="display: flex; gap: 8px; justify-content: flex-end;">
                <button onclick="hideDeleteProjectModal()" style="background: #f1f5f9; color: #64748b; border: 1px solid #e2e8f0; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancel</button>
                <button onclick="confirmDeleteProject()" style="background: #ef4444; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">Delete</button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:3001';
        let selectedFile = null;
        let allNotes = [];
        let displayedNotes = [];
        let projects = new Map(); // Map of projectId -> project data
        let currentProjectId = null;
        let savedNotes = new Map(); // Map of projectId -> Set of noteIds
        let availableSources = new Set();
        let availableProjects = new Set();
        let autoSearchEnabled = true;
        let searchMode = 'smart'; // 'smart' or 'text'
        let autoSearchTimeout = null;
        let currentSearchQuery = '';
        let searchLimit = 10; // Display 10 results at a time
        let totalSearchLimit = 20; // Fetch 20 results total from backend
        let searchOffset = 0;
        let hasMoreResults = false;
        let sidebarCollapsed = false;
        let panelCollapsed = false;
        
        // Separate storage for each search type to enable comparison
        let searchResults = {
            smart: { allNotes: [], displayedNotes: [], hasMoreResults: false, searchOffset: 0 },
            text: { allNotes: [], displayedNotes: [], hasMoreResults: false, searchOffset: 0 }
        };
        
        // Auto-resize textarea function
        function autoResizeTextarea(textarea) {
            // Reset height to auto to get the correct scrollHeight
            textarea.style.height = 'auto';
            // Set height to scrollHeight to fit content
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        // Helper functions for managing search results by type
        function getCurrentSearchResults() {
            return searchResults[searchMode];
        }
        
        function setCurrentSearchResults(results) {
            searchResults[searchMode] = results;
        }
        
        function loadSearchResultsForMode(mode) {
            const results = searchResults[mode];
            allNotes = results.allNotes;
            displayedNotes = results.displayedNotes;
            hasMoreResults = results.hasMoreResults;
            searchOffset = results.searchOffset;
        }
        
        function saveCurrentSearchResults() {
            searchResults[searchMode] = {
                allNotes: allNotes,
                displayedNotes: displayedNotes,
                hasMoreResults: hasMoreResults,
                searchOffset: searchOffset
            };
        }
        
        // Toggle functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = sidebar.querySelector('.toggle-btn');
            const icon = toggleBtn.querySelector('svg path');
            const hamburgerMenu = document.getElementById('hamburger-menu');
            const writingHeader = document.querySelector('.writing-header');
            
            sidebarCollapsed = !sidebarCollapsed;
            sidebar.classList.toggle('collapsed', sidebarCollapsed);
            
            // Show/hide hamburger menu and adjust writing header
            if (sidebarCollapsed) {
                hamburgerMenu.classList.add('show');
                writingHeader.classList.add('sidebar-collapsed');
                icon.setAttribute('d', 'M9 5l7 7-7 7');
                toggleBtn.title = 'Expand sidebar';
            } else {
                hamburgerMenu.classList.remove('show');
                writingHeader.classList.remove('sidebar-collapsed');
                icon.setAttribute('d', 'M15 19l-7-7 7-7');
                toggleBtn.title = 'Collapse sidebar';
            }
        }
        
        function expandSidebar() {
            if (sidebarCollapsed) {
                toggleSidebar();
            }
        }
        
        // Source Viewer Functions
        async function viewSource(sourceId, sourceTitle) {
            try {
                const response = await fetch(`${API_BASE}/sources/${sourceId}/full`);
                if (!response.ok) {
                    throw new Error(`Failed to load source: ${response.status}`);
                }
                
                const data = await response.json();
                showSourceViewer(data, sourceTitle);
                
            } catch (error) {
                console.error('Error loading source:', error);
                alert('Failed to load source document');
            }
        }
        
        async function viewSourceWithChunk(sourceId, sourceTitle, chunkIndex) {
            try {
                const response = await fetch(`${API_BASE}/sources/${sourceId}/full?chunk=${chunkIndex}`);
                if (!response.ok) {
                    throw new Error(`Failed to load source: ${response.status}`);
                }
                
                const data = await response.json();
                showSourceViewer(data, sourceTitle, chunkIndex);
                
            } catch (error) {
                console.error('Error loading source:', error);
                alert('Failed to load source document');
            }
        }
        
        function showSourceViewer(data, sourceTitle, scrollToChunk = null) {
            const sourceViewer = document.getElementById('source-viewer');
            const titleElement = document.getElementById('source-viewer-title');
            const contentElement = document.getElementById('source-viewer-content');
            
            // Update title
            titleElement.textContent = sourceTitle;
            
            // Process content with chunk markers
            let processedContent = data.content;
            
            // Replace chunk markers with HTML elements
            processedContent = processedContent.replace(
                /<!-- CHUNK_START:(\d+) -->([\s\S]*?)<!-- CHUNK_END:\1 -->/g,
                '<div class="chunk-marker" data-chunk="$1">$2</div>'
            );
            
            // Set content
            contentElement.innerHTML = processedContent;
            
            // Show the source viewer
            sourceViewer.classList.add('active');
            
            // Scroll to specific chunk if requested
            if (scrollToChunk !== null) {
                setTimeout(() => {
                    const chunkElement = contentElement.querySelector(`[data-chunk="${scrollToChunk}"]`);
                    if (chunkElement) {
                        chunkElement.classList.add('highlighted');
                        chunkElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
        }
        
        function closeSourceViewer() {
            const sourceViewer = document.getElementById('source-viewer');
            sourceViewer.classList.remove('active');
            sourceViewer.classList.remove('collapsed');
        }
        
        // Source Details Modal Functions
        let currentEditingSourceId = null;
        
        function showSourceDetails(sourceId, title, author) {
            currentEditingSourceId = sourceId;
            
            // Populate the form fields
            document.getElementById('edit-source-title').value = title;
            document.getElementById('edit-source-author').value = author || '';
            
            // Show the modal
            const modal = document.getElementById('source-details-modal');
            modal.style.display = 'flex';
            
            // Add click-outside-to-close functionality
            modal.onclick = function(event) {
                if (event.target === modal) {
                    hideSourceDetails();
                }
            };
        }
        
        function hideSourceDetails() {
            document.getElementById('source-details-modal').style.display = 'none';
            currentEditingSourceId = null;
        }
        
        async function saveSourceDetails() {
            if (!currentEditingSourceId) return;
            
            const newTitle = document.getElementById('edit-source-title').value.trim();
            const newAuthor = document.getElementById('edit-source-author').value.trim();
            
            if (!newTitle) {
                alert('Please enter a title for the source.');
                return;
            }
            
            try {
                // Update the source in the database
                const response = await fetch(`http://localhost:3001/sources/${currentEditingSourceId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: newTitle,
                        author: newAuthor || 'Unknown Author'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Update the UI
                const sourceCard = document.getElementById(`source-${currentEditingSourceId}`);
                if (sourceCard) {
                    const titleElement = sourceCard.querySelector('.source-title');
                    const authorElement = sourceCard.querySelector('.source-author');
                    
                    if (titleElement) titleElement.textContent = newTitle;
                    if (authorElement) authorElement.textContent = newAuthor || 'Unknown Author';
                }
                
                // Close the modal
                hideSourceDetails();
                
                console.log('Source details updated successfully');
                
            } catch (error) {
                console.error('Error updating source details:', error);
                alert('Failed to update source details. Please try again.');
            }
        }
        
        function togglePanel() {
            const panelContainer = document.getElementById('panel-container');
            const toggleBtn = panelContainer.querySelector('.toggle-btn');
            const icon = toggleBtn.querySelector('svg path');
            
            panelCollapsed = !panelCollapsed;
            panelContainer.classList.toggle('collapsed', panelCollapsed);
            
            // Don't close the source viewer - let users keep their notes open while writing
            
            // Update icon
            if (panelCollapsed) {
                icon.setAttribute('d', 'M9 5l7 7-7 7');
                toggleBtn.title = 'Expand panel';
            } else {
                icon.setAttribute('d', 'M15 19l-7-7 7-7');
                toggleBtn.title = 'Collapse panel';
            }
        }
        
        // Initialize projects
        async function initializeProjects() {
            try {
                console.log('Initializing projects...');
                // Load projects from database
                await loadProjectsFromDatabase();
                console.log('Projects loaded:', projects.size, 'projects');
                
                // If no projects exist, create a default one
                if (projects.size === 0) {
                    console.log('No projects found, creating default project...');
                    const defaultProject = await createProjectInDatabase('Untitled Document');
                    if (defaultProject) {
                        projects.set(defaultProject.id, defaultProject);
                        savedNotes.set(defaultProject.id, new Set());
                        currentProjectId = defaultProject.id;
                        console.log('Default project created with ID:', currentProjectId);
                    }
                }
                
                // Load the current project content
                if (currentProjectId) {
                    loadProject(currentProjectId);
                } else {
                    // If no current project is set, use the first available project
                    const firstProjectId = Array.from(projects.keys())[0];
                    if (firstProjectId) {
                        currentProjectId = firstProjectId;
                        loadProject(currentProjectId);
                    }
                }
                
                // Load all sources for the source filter
                loadAllSources();
                
                updateProjectDisplay();
            } catch (error) {
                console.error('Error initializing projects:', error);
                // Fallback to creating a default project
                const defaultProjectId = 'project-1';
                projects.set(defaultProjectId, {
                    id: defaultProjectId,
                    title: 'Untitled Document',
                    content: '',
                    wordCount: 0,
                    lastModified: new Date().toISOString(),
                    createdAt: new Date().toISOString()
                });
                savedNotes.set(defaultProjectId, new Set());
                currentProjectId = defaultProjectId;
                updateProjectDisplay();
            }
        }
        
        async function loadProjectsFromDatabase() {
            try {
                const response = await fetch('http://localhost:3001/projects');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const projectsData = await response.json();
                
                // Clear existing projects
                projects.clear();
                savedNotes.clear();
                
                // Load projects from database
                projectsData.forEach(project => {
                    projects.set(project.id, {
                        id: project.id,
                        title: project.title,
                        content: project.content || '',
                        description: project.description || '',
                        wordCount: project.content ? project.content.split(/\s+/).length : 0,
                        lastModified: project.updated_at || project.created_at,
                        createdAt: project.created_at
                    });
                    savedNotes.set(project.id, new Set());
                });
                
                console.log(`Loaded ${projects.size} projects from database`);
            } catch (error) {
                console.error('Error loading projects from database:', error);
                throw error;
            }
        }
        
        async function saveProjectToDatabase(project) {
            try {
                const response = await fetch(`http://localhost:3001/projects/${project.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: project.title,
                        description: project.description || '',
                        content: project.content || ''
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('Error saving project to database:', error);
                throw error;
            }
        }
        
        async function createProjectInDatabase(title, description = '') {
            try {
                const response = await fetch('http://localhost:3001/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        title: title,
                        description: description,
                        content: ''
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const newProject = await response.json();
                return {
                    id: newProject.id,
                    title: newProject.title,
                    content: newProject.content || '',
                    description: newProject.description || '',
                    wordCount: 0,
                    lastModified: newProject.updated_at || newProject.created_at,
                    createdAt: newProject.created_at
                };
            } catch (error) {
                console.error('Error creating project in database:', error);
                throw error;
            }
        }
        
        async function deleteProjectFromDatabase(projectId) {
            try {
                const response = await fetch(`http://localhost:3001/projects/${projectId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                return true;
            } catch (error) {
                console.error('Error deleting project from database:', error);
                throw error;
            }
        }
        
        async function createProject(title) {
            try {
                const project = await createProjectInDatabase(title);
                projects.set(project.id, project);
                savedNotes.set(project.id, new Set());
                updateProjectDisplay();
                updateAvailableProjects();
                return project.id;
            } catch (error) {
                console.error('Error creating project:', error);
                // Fallback to local creation
                const projectId = 'project-' + Date.now();
                const project = {
                    id: projectId,
                    title: title,
                    content: '',
                    wordCount: 0,
                    lastModified: new Date().toISOString(),
                    createdAt: new Date().toISOString()
                };
                
                projects.set(projectId, project);
                savedNotes.set(projectId, new Set());
                updateProjectDisplay();
                updateAvailableProjects();
                return projectId;
            }
        }
        
        let projectToDelete = null;
        
        function showCreateProjectModal() {
            document.getElementById('create-project-modal').style.display = 'flex';
            document.getElementById('new-project-title').value = '';
            document.getElementById('new-project-title').focus();
        }
        
        function hideCreateProjectModal() {
            document.getElementById('create-project-modal').style.display = 'none';
        }
        
        async function createNewProject() {
            const title = document.getElementById('new-project-title').value.trim();
            if (!title) {
                alert('Please enter a project title');
                return;
            }
            
            const projectId = await createProject(title);
            loadProject(projectId);
            hideCreateProjectModal();
        }
        
        function deleteProject(projectId) {
            if (projects.size <= 1) {
                alert('Cannot delete the last project. You must have at least one project.');
                return;
            }
            
            const project = projects.get(projectId);
            if (!project) return;
            
            projectToDelete = projectId;
            document.getElementById('delete-project-name').textContent = project.title;
            document.getElementById('delete-project-modal').style.display = 'flex';
        }
        
        function hideDeleteProjectModal() {
            document.getElementById('delete-project-modal').style.display = 'none';
            projectToDelete = null;
        }
        
        async function confirmDeleteProject() {
            if (!projectToDelete) return;
            
            const projectId = projectToDelete;
            
            try {
                // Delete from database
                await deleteProjectFromDatabase(projectId);
                
                // Remove from local state
                projects.delete(projectId);
                savedNotes.delete(projectId);
                
                // If we deleted the current project, switch to another one
                if (currentProjectId === projectId) {
                    const remainingProjects = Array.from(projects.keys());
                    currentProjectId = remainingProjects[0];
                    if (currentProjectId) {
                        loadProject(currentProjectId);
                    }
                }
                
                updateProjectDisplay();
                updateAvailableProjects();
                hideDeleteProjectModal();
            } catch (error) {
                console.error('Error deleting project:', error);
                alert('Failed to delete project. Please try again.');
            }
        }
        
        function loadProject(projectId) {
            const project = projects.get(projectId);
            if (!project) return;
            
            currentProjectId = projectId;
            
            // Update the document title and content
            document.getElementById('document-title').value = project.title;
            document.getElementById('document-editor').value = project.content;
            
            // Update the writing meta
            const wordCount = project.content.trim().split(/\s+/).filter(word => word.length > 0).length;
            document.querySelector('.writing-meta').textContent = `${wordCount} words • Last modified: ${new Date(project.lastModified).toLocaleDateString()}`;
            
            // Update the project display to reflect the new selection
            updateProjectDisplay();
        }
        
        async function updateProjectContent() {
            if (!currentProjectId) return;
            
            const project = projects.get(currentProjectId);
            if (!project) return;
            
            const title = document.getElementById('document-title').value;
            const content = document.getElementById('document-editor').value;
            const wordCount = content.trim().split(/\s+/).filter(word => word.length > 0).length;
            
            project.title = title;
            project.content = content;
            project.wordCount = wordCount;
            project.lastModified = new Date().toISOString();
            
            projects.set(currentProjectId, project);
            
            // Save to database
            try {
                await saveProjectToDatabase(project);
            } catch (error) {
                console.error('Error saving project to database:', error);
                // Continue with local update even if database save fails
            }
            
            updateProjectDisplay();
        }
        
        function updateProjectDisplay() {
            const projectsContainer = document.getElementById('projects-container');
            if (!projectsContainer) return;
            
            projectsContainer.innerHTML = '';
            
            projects.forEach(project => {
                const savedCount = savedNotes.get(project.id)?.size || 0;
                const isCurrent = project.id === currentProjectId;
                
                const projectCard = document.createElement('div');
                projectCard.className = 'project-card';
                if (isCurrent) {
                    projectCard.classList.add('active');
                }
                
                projectCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 600; color: #1e293b; margin-bottom: 4px;">${project.title}</div>
                            <div style="font-size: 12px; color: #64748b;">${project.wordCount} words • ${savedCount} saved notes</div>
                        </div>
                        <button onclick="event.stopPropagation(); deleteProject('${project.id}')" 
                                style="background: none; border: none; color: #ef4444; cursor: pointer; padding: 4px; border-radius: 4px; transition: background 0.2s ease;"
                                onmouseover="this.style.background='#fef2f2'" 
                                onmouseout="this.style.background='none'"
                                title="Delete project">
                            <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                `;
                
                projectCard.onclick = () => loadProject(project.id);
                projectsContainer.appendChild(projectCard);
            });
        }
        
        // Panel switching function
        function switchToPanel(panelName, element) {
            console.log('Switching to panel:', panelName);
            
            // If the middle panel is collapsed, expand it first
            if (panelCollapsed) {
                togglePanel();
            }
            
            // Update navigation active state
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            element.classList.add('active');
            
            // Update panel visibility
            document.querySelectorAll('.panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            const targetPanel = document.getElementById(panelName + '-panel');
            if (targetPanel) {
                targetPanel.classList.add('active');
                console.log('Successfully switched to:', panelName);
            } else {
                console.error('Panel not found:', panelName + '-panel');
            }
            
            // Load sources when switching to library
            if (panelName === 'library') {
                console.log('Loading library sources...');
                loadSourcesFromBackend();
            }
            
            // Update projects when switching to notes
            if (panelName === 'notes') {
                console.log('Updating available projects...');
                updateAvailableProjects();
                loadAllSources();
            }
        }
        
        // Search mode toggle functionality
        function toggleSearchMode() {
            const smartSearchRadio = document.querySelector('input[name="search-mode"][value="smart"]');
            const textSearchRadio = document.querySelector('input[name="search-mode"][value="text"]');
            const autoSearchContainer = document.getElementById('auto-search-container');
            const searchInput = document.getElementById('notes-search');
            
            // Save current results before switching
            saveCurrentSearchResults();
            
            if (smartSearchRadio.checked) {
                searchMode = 'smart';
                autoSearchContainer.style.display = 'flex';
                searchInput.placeholder = 'Smart search with semantic understanding';
                // Re-enable auto-search for smart mode
                autoSearchEnabled = true;
                document.getElementById('auto-search-toggle').checked = true;
            } else if (textSearchRadio.checked) {
                searchMode = 'text';
                autoSearchContainer.style.display = 'none';
                searchInput.placeholder = 'Enter search terms (use quotes for exact phrases, OR for alternatives, - to exclude)';
                // Disable auto-search for text mode
                autoSearchEnabled = false;
                document.getElementById('auto-search-toggle').checked = false;
            }
            
            console.log('Search mode:', searchMode);
            
            // Clear any pending search
            if (autoSearchTimeout) {
                clearTimeout(autoSearchTimeout);
                autoSearchTimeout = null;
            }
            
            // Load results for the new mode, or show empty state if no results exist
            const currentResults = searchResults[searchMode];
            if (currentResults.allNotes.length > 0) {
                loadSearchResultsForMode(searchMode);
                updateAvailableSources(allNotes);
                applyFilters();
            } else {
                displayEmptyState();
            }
        }

        // Auto-search toggle functionality
        function toggleAutoSearch() {
            autoSearchEnabled = document.getElementById('auto-search-toggle').checked;
            console.log('Auto-search', autoSearchEnabled ? 'enabled' : 'disabled');
            
            // Clear any pending auto-search
            if (autoSearchTimeout) {
                clearTimeout(autoSearchTimeout);
                autoSearchTimeout = null;
            }
            
            // Hide status indicator when disabled
            const statusDiv = document.getElementById('auto-search-status');
            if (!autoSearchEnabled) {
                statusDiv.style.opacity = '0';
            }
        }
        
        
        function showAutoSearchStatus() {
            if (!autoSearchEnabled) return;
            
            const statusDiv = document.getElementById('auto-search-status');
            statusDiv.style.opacity = '1';
            
            // Hide after 2 seconds
            setTimeout(() => {
                statusDiv.style.opacity = '0';
            }, 2000);
        }
        
        function extractMeaningfulText() {
            const editor = document.getElementById('document-editor');
            const text = editor.value;
            const cursorPosition = editor.selectionStart;
            
            console.log('ExtractMeaningfulText - Cursor position:', cursorPosition);
            console.log('ExtractMeaningfulText - Text length:', text.length);
            
            if (!text || cursorPosition === undefined) {
                console.log('ExtractMeaningfulText - No text or cursor position');
                return '';
            }
            
            // Extract 1000 characters of context: 500 before + 500 after cursor
            // If no text after cursor, use 1000 before cursor
            const contextSize = 1000;
            const beforeSize = 500;
            const afterSize = 500;
            
            const beforeCursor = text.substring(0, cursorPosition);
            const afterCursor = text.substring(cursorPosition);
            
            let textChunk = '';
            
            // Check if there's enough text after cursor
            if (afterCursor.length >= afterSize) {
                // Use 500 before + 500 after
                const start = Math.max(0, cursorPosition - beforeSize);
                const end = Math.min(text.length, cursorPosition + afterSize);
                textChunk = text.substring(start, end);
                console.log('ExtractMeaningfulText - Using 500/500 split');
            } else {
                // Use 1000 before cursor if not enough text after
                const start = Math.max(0, cursorPosition - contextSize);
                textChunk = text.substring(start, cursorPosition + afterCursor.length);
                console.log('ExtractMeaningfulText - Using 1000 before (fallback)');
            }
            
            // Clean up the text chunk
            textChunk = textChunk.trim();
            
            // No minimum character requirement - allow even single sentences
            console.log('ExtractMeaningfulText - Returning:', textChunk);
            return textChunk;
        }
        
        function handleEditorInput() {
            // Auto-save project content
            updateProjectContent();
            
            console.log('HandleEditorInput - Auto-search enabled:', autoSearchEnabled);
            
            if (!autoSearchEnabled) return;
            
            // Clear any existing timeout
            if (autoSearchTimeout) {
                clearTimeout(autoSearchTimeout);
            }
            
            // Set a new timeout
            autoSearchTimeout = setTimeout(() => {
                const editor = document.getElementById('document-editor');
                const text = editor.value.trim();
                
                console.log('HandleEditorInput - Text length:', text.length);
                
                // No minimum text length requirement - allow searches even with single sentences
                const searchQuery = extractMeaningfulText();
                console.log('HandleEditorInput - Search query:', searchQuery);
                
                if (searchQuery && searchQuery.trim().length > 0) {
                    console.log('Auto-searching for:', searchQuery);
                    
                    // Show status indicator
                    showAutoSearchStatus();
                    
                    // Perform the search
                    performAutoSearch(searchQuery);
                } else {
                    console.log('HandleEditorInput - Search query empty');
                }
            }, 2500); // Wait 2.5 seconds after user stops typing
        }
        
        async function performAutoSearch(query) {
            if (!autoSearchEnabled) return;
            
            // Reset for new auto-search
            searchOffset = 0;
            currentSearchQuery = query;
            
            
            try {
                const endpoint = '/search';
                const requestBody = {
                    query: query, // Use original query for search
                    limit: totalSearchLimit // Fetch 20 results from backend
                };
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`Search failed: ${response.status}`);
                }
                
                const results = await response.json();
                
                // Store all results and show first 8
                allNotes = results;
                displayedNotes = results.slice(0, 8);
                searchOffset = 8;
                hasMoreResults = results.length > 8;
                
                // Save results for this search type
                saveCurrentSearchResults();
                
                updateAvailableSources(results);
                applyFilters();
                
            } catch (error) {
                console.error('Auto-search error:', error);
            }
        }
        
        // Handle keydown events in search input
        function handleSearchKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                if (searchMode === 'text') {
                    performTextSearch();
                } else if (!autoSearchEnabled) {
                    performManualSearch();
                }
            }
        }
        
        
        function getEditorContext() {
            // Get context from the editor
            const editor = document.getElementById('editor');
            if (!editor) return '';
            
            const text = editor.value;
            const cursorPosition = editor.selectionStart;
            
            if (!text || cursorPosition === undefined) {
                return '';
            }
            
            // Extract 1000 characters of context: 500 before + 500 after cursor
            const contextSize = 1000;
            const beforeSize = 500;
            const afterSize = 500;
            
            const beforeCursor = text.substring(0, cursorPosition);
            const afterCursor = text.substring(cursorPosition);
            
            let textChunk = '';
            
            // Check if there's enough text after cursor
            if (afterCursor.length >= afterSize) {
                // Use 500 before + 500 after
                const start = Math.max(0, cursorPosition - beforeSize);
                const end = Math.min(text.length, cursorPosition + afterSize);
                textChunk = text.substring(start, end);
            } else {
                // Use 1000 before cursor if not enough text after
                const start = Math.max(0, cursorPosition - contextSize);
                textChunk = text.substring(start, cursorPosition + afterCursor.length);
            }
            
            return textChunk.trim();
        }
        
        
        // Text search function (literal text search with operators)
        async function performTextSearch() {
            console.log('performTextSearch called');
            const searchInput = document.getElementById('notes-search');
            let query = searchInput.value.trim();
            
            if (query.length === 0) {
                console.log('Empty query - showing empty state');
                displayEmptyState();
                return;
            }
            
            // Reset for new search
            searchOffset = 0;
            currentSearchQuery = query;
            
            try {
                const response = await fetch(`${API_BASE}/text-search`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        limit: totalSearchLimit // Fetch 20 results from backend
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Text search failed: ${response.status}`);
                }
                
                const results = await response.json();
                console.log('Text search response received:', results.length, 'results');
                
                // Store all results and show first 10
                allNotes = results;
                displayedNotes = results.slice(0, searchLimit); // Show first 10
                hasMoreResults = results.length > searchLimit; // Check if there are more than 10
                console.log('Text search - stored', allNotes.length, 'results, showing', displayedNotes.length);
                
                // Save results for this search type
                saveCurrentSearchResults();
                
                updateAvailableSources(results);
                applyFilters();
                
            } catch (error) {
                console.error('Text search error:', error);
                displayErrorState();
            }
        }
        
        
        // Manual search function (when auto-search is disabled)
        async function performManualSearch() {
            const searchInput = document.getElementById('notes-search');
            let query = searchInput.value.trim();
            
            if (query.length < 3) {
                displayEmptyState();
                return;
            }
            
            
            // Reset for new search
            searchOffset = 0;
            currentSearchQuery = query; // Use original query
            
            try {
                const endpoint = '/search';
                const requestBody = {
                    query: query, // Use original query for search
                    limit: totalSearchLimit // Fetch 20 results from backend
                };
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`Search failed: ${response.status}`);
                }
                
                const results = await response.json();
                
                if (results.length === 0) {
                    displayEmptyState();
                    return;
                }
                
                allNotes = results;
                displayedNotes = results.slice(0, searchLimit); // Show first 10
                hasMoreResults = results.length > searchLimit; // Check if there are more than 10
                
                // Save results for this search type
                saveCurrentSearchResults();
                
                updateAvailableSources(results);
                applyFilters();
                
            } catch (error) {
                console.error('Manual search error:', error);
                displayErrorState();
            }
        }
        
        // Search functionality with debouncing for textarea
        async function performSearch() {
            console.log('performSearch called - searchMode:', searchMode, 'autoSearchEnabled:', autoSearchEnabled);
            console.log('Current search input value:', document.getElementById('notes-search').value);
            
            // For text search mode, don't auto-search
            if (searchMode === 'text') {
                console.log('Text search mode - skipping auto-search');
                return;
            }
            
            // Check if auto-search is enabled
            if (!autoSearchEnabled) {
                console.log('Auto-search disabled - skipping');
                return;
            }
            
            // Clear existing timeout
            if (autoSearchTimeout) {
                clearTimeout(autoSearchTimeout);
            }
            
            // Debounce the search for textarea input
            autoSearchTimeout = setTimeout(async () => {
                const searchInput = document.getElementById('notes-search');
                let query = searchInput.value.trim();
                
                // No minimum character requirement - allow single word searches
                if (query.length === 0) {
                    displayEmptyState();
                    return;
                }
                
                // Reset for new search
                searchOffset = 0;
                currentSearchQuery = query;
                
                await executeSearch(query, searchLimit, searchOffset, true);
            }, 1000); // 1 second debounce for manual typing
        }
        
        async function executeSearch(query, limit, offset = 0, isNewSearch = false) {
            try {
                console.log('executeSearch called with query:', query, 'limit:', limit, 'offset:', offset, 'isNewSearch:', isNewSearch);
                const endpoint = '/search';
                
                const requestBody = {
                    query: query,
                    limit: totalSearchLimit // Fetch 20 results from backend
                };
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`Search failed: ${response.status}`);
                }
                
                const results = await response.json();
                console.log('Search response received:', results.length, 'results');
                
                if (isNewSearch) {
                    // New search: store all results and show first 10
                    allNotes = results;
                    displayedNotes = results.slice(0, searchLimit); // Show first 10
                    hasMoreResults = results.length > searchLimit; // Check if there are more than 10
                    console.log('New search - stored', allNotes.length, 'results, showing', displayedNotes.length);
                    console.log('First result preview:', results[0] ? results[0].content.substring(0, 100) : 'No results');
                    
                    // Save results for this search type
                    saveCurrentSearchResults();
                    
                    updateAvailableSources(results);
                } else {
                    // This is a "load more" operation - show next 10 from already fetched results
                    const startIndex = displayedNotes.length;
                    const endIndex = Math.min(startIndex + searchLimit, allNotes.length);
                    const newResults = allNotes.slice(startIndex, endIndex);
                    
                    displayedNotes = [...displayedNotes, ...newResults];
                    hasMoreResults = endIndex < allNotes.length; // Check if there are more results to show
                    
                    // Update saved results
                    saveCurrentSearchResults();
                }
                
                applyFilters();
                
            } catch (error) {
                console.error('Search error:', error);
                displayErrorState();
            }
        }
        
        async function loadMoreResults() {
            if (!hasMoreResults) return;
            
            const loadMoreBtn = document.getElementById('load-more-btn');
            if (loadMoreBtn) {
                loadMoreBtn.disabled = true;
                loadMoreBtn.textContent = 'Loading...';
            }
            
            try {
                // Check if this is a source-specific view (using dropdown filter)
                const sourceFilter = document.getElementById('source-filter').value;
                const searchInput = document.getElementById('notes-search').value.trim();
                
                if (sourceFilter && !searchInput) {
                    // We're viewing a specific source without a search query
                    // All notes are already loaded, just show more from the existing array
                    const startIndex = displayedNotes.length;
                    const endIndex = Math.min(startIndex + searchLimit, allNotes.length);
                    const notesToAdd = allNotes.slice(startIndex, endIndex);
                    
                    displayedNotes = [...displayedNotes, ...notesToAdd];
                    hasMoreResults = endIndex < allNotes.length;
                    
                    applyFilters();
                } else if (currentSearchQuery.startsWith('source:')) {
                    // Legacy source-specific search (shouldn't happen with new implementation)
                    const startIndex = displayedNotes.length;
                    const endIndex = Math.min(startIndex + searchLimit, allNotes.length);
                    const notesToAdd = allNotes.slice(startIndex, endIndex);
                    
                    displayedNotes = [...displayedNotes, ...notesToAdd];
                    hasMoreResults = endIndex < allNotes.length;
                    
                    applyFilters();
                } else if (currentSearchQuery) {
                    // Regular search - show next 10 from already fetched results
                    const startIndex = displayedNotes.length;
                    const endIndex = Math.min(startIndex + searchLimit, allNotes.length);
                    const notesToAdd = allNotes.slice(startIndex, endIndex);
                    
                    displayedNotes = [...displayedNotes, ...notesToAdd];
                    hasMoreResults = endIndex < allNotes.length;
                    
                    applyFilters();
                }
                
            } catch (error) {
                console.error('Load more error:', error);
            } finally {
                if (loadMoreBtn) {
                    loadMoreBtn.disabled = false;
                    loadMoreBtn.textContent = 'Show More';
                }
            }
        }
        
        function updateAvailableSources(notes) {
            const multiselectOptions = document.getElementById('multiselect-options');
            if (multiselectOptions) {
                availableSources.clear();
                
                // Clear existing options except "All Sources"
                const existingOptions = multiselectOptions.querySelectorAll('.multiselect-option:not(:first-child)');
                existingOptions.forEach(option => option.remove());
                
                // Add unique sources from the provided notes
                notes.forEach(note => {
                    if (!availableSources.has(note.source_title)) {
                        availableSources.add(note.source_title);
                        
                        const optionDiv = document.createElement('div');
                        optionDiv.className = 'multiselect-option';
                        optionDiv.setAttribute('data-value', note.source_title);
                        
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.id = `option-${note.source_title.replace(/\s+/g, '-')}`;
                        checkbox.value = note.source_title;
                        checkbox.onchange = () => updateMultiselectDisplay();
                        
                        const label = document.createElement('label');
                        label.setAttribute('for', checkbox.id);
                        label.textContent = note.source_title;
                        
                        optionDiv.appendChild(checkbox);
                        optionDiv.appendChild(label);
                        multiselectOptions.appendChild(optionDiv);
                    }
                });
            }
        }
        
        async function loadAllSources() {
            try {
                // Get all sources from the backend
                const response = await fetch(`${API_BASE}/sources`);
                if (response.ok) {
                    const sources = await response.json();
                    
                    // Update source filter with all available sources
                    const sourceFilter = document.getElementById('source-filter');
                    if (sourceFilter && sourceFilter.children) {
                        availableSources.clear();
                        
                        // Clear existing options except "All Sources"
                        while (sourceFilter.children.length > 1) {
                            sourceFilter.removeChild(sourceFilter.lastChild);
                        }
                        
                        // Add all sources
                        sources.forEach(source => {
                            if (!availableSources.has(source.title)) {
                                availableSources.add(source.title);
                                const option = document.createElement('option');
                                option.value = source.title;
                                option.textContent = source.title;
                                sourceFilter.appendChild(option);
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading sources:', error);
            }
        }
        
        function updateAvailableProjects() {
            const projectFilter = document.getElementById('project-filter');
            if (projectFilter && projectFilter.children) {
                availableProjects.clear();
                
                // Clear existing options except "All Notes"
                while (projectFilter.children.length > 1) {
                    projectFilter.removeChild(projectFilter.lastChild);
                }
                
                // Add all projects
                projects.forEach(project => {
                    if (!availableProjects.has(project.title)) {
                        availableProjects.add(project.title);
                        const option = document.createElement('option');
                        option.value = project.id;
                        option.textContent = project.title;
                        projectFilter.appendChild(option);
                    }
                });
            }
        }
        
        function getSelectedSources() {
            const selectedCheckboxes = document.querySelectorAll('.multiselect-option input[type="checkbox"]:checked');
            const selectedSources = [];
            
            selectedCheckboxes.forEach(checkbox => {
                // Skip the "All Sources" checkbox
                if (checkbox.id === 'option-all') {
                    return;
                }
                
                const label = checkbox.nextElementSibling;
                if (label && label.textContent !== 'All Sources') {
                    selectedSources.push(label.textContent.trim());
                }
            });
            
            return selectedSources;
        }
        
        function applyFilters() {
            console.log('applyFilters called');
            const sourceFilter = document.getElementById('source-filter-container');
            const projectFilter = document.getElementById('project-filter');
            
            if (!sourceFilter || !projectFilter) {
                console.log('Missing filter elements, returning');
                return;
            }
            
            // Get selected sources from multiselect
            const selectedSources = getSelectedSources();
            const projectValue = projectFilter.value;
            
            let filteredNotes = [...allNotes]; // Use allNotes for filtering
            
            // Apply source filter
            if (selectedSources.length > 0) {
                filteredNotes = filteredNotes.filter(note => selectedSources.includes(note.source_title));
            }
            
            // Apply project filter
            if (projectValue && projectValue !== '') {
                // Show only notes saved to the specific project
                const projectNotes = savedNotes.get(projectValue);
                if (projectNotes) {
                    filteredNotes = filteredNotes.filter(note => {
                        const noteId = note.source_id + '-' + note.chunk_index;
                        return projectNotes.has(noteId);
                    });
                } else {
                    // If no saved notes for this project, show empty
                    filteredNotes = [];
                }
            }
            
            
            displayNotes(filteredNotes);
        }
        
        function displayNotes(notes) {
            console.log('displayNotes called with', notes ? notes.length : 'null', 'notes');
            const resultsContainer = document.getElementById('notes-results');
            
            if (!notes || notes.length === 0) {
                console.log('No notes to display, showing empty state');
                displayEmptyState();
                return;
            }
            
            resultsContainer.innerHTML = '';
            
            notes.forEach(note => {
                const noteCard = createNoteCard(note);
                resultsContainer.appendChild(noteCard);
            });
            
            // Add load more button if there are more results available
            if (hasMoreResults) {
                const loadMoreContainer = document.createElement('div');
                loadMoreContainer.className = 'load-more-container';
                loadMoreContainer.innerHTML = `
                    <button class="load-more-btn" id="load-more-btn" onclick="loadMoreResults()">
                        Show More
                    </button>
                `;
                resultsContainer.appendChild(loadMoreContainer);
            }
        }
        
        // Highlight search terms in text
        function highlightSearchTerms(text, searchQuery) {
            if (!searchQuery || searchQuery.trim().length === 0) {
                return text;
            }
            
            // Parse the search query to extract terms for highlighting
            const terms = [];
            
            // Extract exact phrases (quoted text)
            const phraseRegex = /"([^"]+)"/g;
            let match;
            while ((match = phraseRegex.exec(searchQuery)) !== null) {
                terms.push({
                    text: match[1],
                    isExact: true
                });
            }
            
            // Extract individual words (excluding OR, -, and quoted phrases)
            const remainingQuery = searchQuery.replace(/"([^"]+)"/g, '').trim();
            const words = remainingQuery.split(/\s+/)
                .filter(word => word.length > 0 && word.toUpperCase() !== 'OR' && !word.startsWith('-'))
                .map(word => ({
                    text: word,
                    isExact: false
                }));
            
            terms.push(...words);
            
            if (terms.length === 0) {
                return text;
            }
            
            let highlightedText = text;
            
            // Highlight exact phrases first
            terms.filter(term => term.isExact).forEach(term => {
                const regex = new RegExp(`(${escapeRegExp(term.text)})`, 'gi');
                highlightedText = highlightedText.replace(regex, '<mark class="search-highlight">$1</mark>');
            });
            
            // Highlight individual words
            terms.filter(term => !term.isExact).forEach(term => {
                const regex = new RegExp(`\\b(${escapeRegExp(term.text)})\\b`, 'gi');
                highlightedText = highlightedText.replace(regex, '<mark class="search-highlight">$1</mark>');
            });
            
            return highlightedText;
        }
        
        // Escape special regex characters
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function createNoteCard(note, showContextButton = true) {
            const card = document.createElement('div');
            card.className = 'note-card';
            card.setAttribute('data-source-id', note.source_id);
            
            const noteId = note.source_id + '-' + note.chunk_index;
            const projectNotes = savedNotes.get(currentProjectId);
            const isSaved = projectNotes && projectNotes.has ? projectNotes.has(noteId) : false;
            
            // Calculate percentage score
            const percentage = Math.round(note.score * 100);
            
            // Create author text if available
            const authorText = note.author && note.author !== 'Unknown Author' ? ` by ${note.author}` : '';
            
            // Generate context button HTML conditionally
            const contextButton = showContextButton ? `
                        <button class="note-action-btn context-btn" 
                                data-source-id="${note.source_id}" 
                                data-source-title="${note.source_title.replace(/"/g, '&quot;')}" 
                                data-chunk-index="${note.chunk_index}"
                                title="View note in context">
                            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                      d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                            </svg>
                        </button>` : '';
            
            // Generate delete button HTML only when not showing context button (i.e., in source notes panel)
            const deleteButton = !showContextButton ? `
                        <button class="note-action-btn delete-btn" 
                                data-source-id="${note.source_id}" 
                                data-chunk-index="${note.chunk_index}"
                                onclick="confirmDeleteNote('${note.source_id}', ${note.chunk_index}, this)" 
                                title="Delete note">
                            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                      d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>` : '';
            
            card.innerHTML = `
                <div class="note-header">
                    <div class="note-meta">
                        <div class="note-score">${percentage}% match</div>
                        <div class="note-source">${note.source_title}${authorText}</div>
                    </div>
                    <div class="note-actions">
                        <button class="note-action-btn ${isSaved ? 'saved' : ''}" 
                                onclick="toggleSaveNote('${noteId}')" 
                                title="${isSaved ? 'Remove from project' : 'Save to project'}">
                            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                      d="${isSaved ? 'M5 13l4 4L19 7' : 'M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z'}" />
                            </svg>
                        </button>
                        ${contextButton}
                        <button class="note-action-btn copy-btn" 
                                data-content="${note.content.replace(/"/g, '&quot;')}"
                                data-source="${note.source_title.replace(/"/g, '&quot;')}"
                                data-author="${(note.author || '').replace(/"/g, '&quot;')}"
                                onclick="copyNoteContent(this.dataset.content, this.dataset.source, this.dataset.author, this)" 
                                title="Copy note content">
                            <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" 
                                      d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                            </svg>
                        </button>
                        ${deleteButton}
                    </div>
                </div>
                <div class="note-content">${searchMode === 'text' ? highlightSearchTerms(note.content, currentSearchQuery) : note.content}</div>
            `;
            
            // Add event listener for context button
            const contextBtn = card.querySelector('.context-btn');
            if (contextBtn) {
                contextBtn.addEventListener('click', function() {
                    const sourceId = this.dataset.sourceId;
                    const sourceTitle = this.dataset.sourceTitle;
                    const chunkIndex = parseInt(this.dataset.chunkIndex);
                    showNoteInContext(sourceId, sourceTitle, chunkIndex);
                });
            }
            
            return card;
        }
        
        function confirmDeleteNote(sourceId, chunkIndex, buttonElement) {
            // Check if this is the first click (delete icon) or second click (confirm)
            const isConfirming = buttonElement.classList.contains('confirming');
            
            if (!isConfirming) {
                // First click - change to confirm state
                buttonElement.classList.add('confirming');
                buttonElement.title = 'Click again to confirm delete';
                
                // Change icon to checkmark
                const icon = buttonElement.querySelector('svg path');
                icon.setAttribute('d', 'M5 13l4 4L19 7');
                
                // Change color to red
                buttonElement.style.color = '#ef4444';
                
                // Reset after 3 seconds if not clicked again
                setTimeout(() => {
                    if (buttonElement.classList.contains('confirming')) {
                        resetDeleteButton(buttonElement);
                    }
                }, 3000);
            } else {
                // Second click - actually delete the note
                deleteNote(sourceId, chunkIndex, buttonElement);
            }
        }
        
        function resetDeleteButton(buttonElement) {
            buttonElement.classList.remove('confirming');
            buttonElement.title = 'Delete note';
            buttonElement.style.color = '';
            
            // Reset icon to trash
            const icon = buttonElement.querySelector('svg path');
            icon.setAttribute('d', 'M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16');
        }
        
        async function deleteNote(sourceId, chunkIndex, buttonElement) {
            try {
                const response = await fetch(`${API_BASE}/delete-note`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        source_id: sourceId, 
                        chunk_index: chunkIndex 
                    })
                });
                
                if (response.ok) {
                    // Remove the note card from the UI
                    const noteCard = buttonElement.closest('.note-card');
                    noteCard.remove();
                    
                    // Update the source's chunk count in the UI
                    updateSourceChunkCount(sourceId);
                } else {
                    const error = await response.json();
                    console.error('Error deleting note:', error);
                    alert('Failed to delete note. Please try again.');
                    resetDeleteButton(buttonElement);
                }
            } catch (error) {
                console.error('Error deleting note:', error);
                alert('Failed to delete note. Please try again.');
                resetDeleteButton(buttonElement);
            }
        }
        
        function updateSourceChunkCount(sourceId) {
            // Find the source card and update its chunk count
            const sourceCard = document.querySelector(`[data-source-id="${sourceId}"]`);
            if (sourceCard) {
                const statusBadge = sourceCard.querySelector('.status-badge');
                if (statusBadge) {
                    // Count remaining notes for this source by looking for note cards with matching source_id
                    const remainingNotes = document.querySelectorAll(`.note-card[data-source-id="${sourceId}"]`).length;
                    statusBadge.textContent = `${remainingNotes} notes`;
                }
            }
        }

        function toggleSaveNote(noteId) {
            console.log('toggleSaveNote called with noteId:', noteId, 'currentProjectId:', currentProjectId);
            if (!currentProjectId) {
                console.log('No current project selected, cannot save note');
                alert('Please select a project first before saving notes');
                return;
            }
            
            // Ensure the current project has a savedNotes entry
            if (!savedNotes.has(currentProjectId)) {
                savedNotes.set(currentProjectId, new Set());
            }
            
            const projectNotes = savedNotes.get(currentProjectId);
            
            if (projectNotes.has(noteId)) {
                projectNotes.delete(noteId);
                console.log('Removed note from project:', noteId);
            } else {
                projectNotes.add(noteId);
                console.log('Added note to project:', noteId);
            }
            
            // Update the button appearance
            const button = event.target.closest('.note-action-btn');
            const isSaved = projectNotes.has(noteId);
            
            button.classList.toggle('saved', isSaved);
            button.title = isSaved ? 'Remove from project' : 'Save to project';
            
            // Update the icon
            const svg = button.querySelector('svg path');
            svg.setAttribute('d', isSaved ? 'M5 13l4 4L19 7' : 'M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z');
            
            // Update project display
            updateProjectDisplay();
            
            const project = projects.get(currentProjectId);
            console.log(`Note ${noteId} ${isSaved ? 'saved to' : 'removed from'} project: ${project?.title}`);
        }
        
        function showSourceNotes(sourceTitle) {
            // Set the source filter and apply filters
            document.getElementById('source-filter').value = sourceTitle;
            applyFilters();
            console.log(`Showing all notes from: ${sourceTitle}`);
        }
        
        function openSavedNotes() {
            const sourceViewer = document.getElementById('source-viewer');
            const sourceViewerContent = document.getElementById('source-viewer-content');
            
            // Load saved notes for current project
            const projectNotes = savedNotes.get(currentProjectId);
            if (projectNotes && projectNotes.size > 0) {
                showSavedNotesInPanel(projectNotes);
            } else {
                sourceViewerContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                            </svg>
                        </div>
                        <div class="empty-text">No saved notes for this project</div>
                    </div>
                `;
            }
            
            sourceViewer.style.display = 'block';
        }
        
        function showSavedNotesInPanel(projectNotes) {
            const sourceViewerContent = document.getElementById('source-viewer-content');
            
            // Clear the content area
            sourceViewerContent.innerHTML = '';
            
            // Add each saved note directly to the content area
            Array.from(projectNotes).forEach(noteId => {
                const note = allNotes.find(n => (n.source_id + '-' + n.chunk_index) === noteId);
                if (note) {
                    const noteCard = createNoteCard(note, false, true); // Don't show context button for saved notes
                    sourceViewerContent.appendChild(noteCard);
                }
            });
        }
        
        function closeSourceViewer() {
            const sourceViewer = document.getElementById('source-viewer');
            sourceViewer.style.display = 'none';
        }
        
        function toggleMultiselect() {
            const dropdown = document.getElementById('multiselect-dropdown');
            if (dropdown.style.display === 'none') {
                dropdown.style.display = 'block';
            } else {
                dropdown.style.display = 'none';
            }
        }
        
        function filterMultiselectOptions() {
            const searchTerm = document.getElementById('multiselect-search').value.toLowerCase();
            const options = document.querySelectorAll('.multiselect-option');
            
            options.forEach(option => {
                const label = option.querySelector('label').textContent.toLowerCase();
                if (label.includes(searchTerm)) {
                    option.style.display = 'flex';
                } else {
                    option.style.display = 'none';
                }
            });
        }
        
        function toggleAllSources() {
            const allCheckbox = document.getElementById('option-all');
            const otherCheckboxes = document.querySelectorAll('.multiselect-option input[type="checkbox"]:not(#option-all)');
            
            if (allCheckbox.checked) {
                otherCheckboxes.forEach(checkbox => {
                    checkbox.checked = true;
                });
            } else {
                otherCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            }
            
            updateMultiselectDisplay();
        }
        
        function toggleSourceOption(sourceTitle) {
            const checkbox = document.querySelector(`input[value="${sourceTitle}"]`);
            if (checkbox) {
                checkbox.checked = !checkbox.checked;
                updateMultiselectDisplay();
            }
        }
        
        function updateMultiselectDisplay() {
            const selectedCheckboxes = document.querySelectorAll('.multiselect-option input[type="checkbox"]:checked');
            const selectedContainer = document.getElementById('multiselect-selected');
            
            selectedContainer.innerHTML = '';
            
            selectedCheckboxes.forEach(checkbox => {
                const label = checkbox.nextElementSibling.textContent;
                const tag = document.createElement('span');
                tag.className = 'multiselect-tag';
                tag.innerHTML = `${label} <span class="remove" onclick="toggleSourceOption('${label}')">×</span>`;
                selectedContainer.appendChild(tag);
            });
            
            if (selectedCheckboxes.length === 0) {
                selectedContainer.innerHTML = '<span class="placeholder">All Sources</span>';
            }
        }
        
        async function copyNoteContent(content, sourceTitle, author, buttonElement) {
            console.log('=== COPY FUNCTION CALLED ===');
            console.log('copyNoteContent called with:', { content: content.substring(0, 50), sourceTitle, author, buttonElement });
            
            const button = buttonElement || (event && event.target.closest('.note-action-btn'));
            if (!button) {
                console.error('Could not find button element');
                return;
            }
            const originalTitle = button.title;
            
            // Extract just the content without the title/author header
            let cleanContent = content;
            
            // Simple approach: remove title and author step by step
            console.log('DEBUG: Original content:', content.substring(0, 100) + '...');
            console.log('DEBUG: Source title:', sourceTitle);
            console.log('DEBUG: Author:', author);
            
            // Step 1: Remove the title from the beginning
            const titlePattern = new RegExp(`^${sourceTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*`, 'i');
            cleanContent = cleanContent.replace(titlePattern, '').trim();
            console.log('DEBUG: After title removal:', cleanContent.substring(0, 100) + '...');
            
            // Step 2: Remove "by Author" or just "Author" from the beginning
            // If author is empty or "Unknown Author", try to extract it from the content
            let actualAuthor = author;
            if (!actualAuthor || actualAuthor === 'Unknown Author') {
                // Try to extract author from "by Author" pattern
                const byAuthorMatch = cleanContent.match(/^by\s+([^\n]+)/i);
                if (byAuthorMatch) {
                    actualAuthor = byAuthorMatch[1].trim();
                    console.log('DEBUG: Extracted author from content:', actualAuthor);
                }
            }
            
            if (actualAuthor && actualAuthor !== 'Unknown Author') {
                const authorPatterns = [
                    new RegExp(`^by\\s+${actualAuthor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s+`, 'i'),
                    new RegExp(`^${actualAuthor.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s+`, 'i')
                ];
                
                for (const pattern of authorPatterns) {
                    const newContent = cleanContent.replace(pattern, '').trim();
                    if (newContent !== cleanContent) {
                        cleanContent = newContent;
                        console.log('DEBUG: Author removed:', cleanContent.substring(0, 100) + '...');
                        break;
                    }
                }
            }
            
            // Format the citation using the extracted author
            const cleanAuthor = actualAuthor && actualAuthor !== 'Unknown Author' && actualAuthor.trim() ? actualAuthor.trim() : '';
            const citation = cleanAuthor 
                ? `(${cleanAuthor}, ${sourceTitle})`
                : `(${sourceTitle})`;
            
            // Normalize whitespace and create the full text to copy
            const normalizedContent = cleanContent.replace(/\s+/g, ' ').trim();
            const fullText = `${normalizedContent} ${citation}`;
            
            // Debug logging
            console.log('Original content:', content.substring(0, 100) + '...');
            console.log('Clean content:', cleanContent.substring(0, 100) + '...');
            console.log('Full text to copy:', fullText.substring(0, 100) + '...');
            
            try {
                // Check if clipboard API is available
                if (navigator.clipboard && window.isSecureContext) {
                    // Modern clipboard API
                    await navigator.clipboard.writeText(fullText);
                } else {
                    // Fallback for older browsers or non-secure contexts
                    const textArea = document.createElement('textarea');
                    textArea.value = fullText;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    if (!successful) {
                        throw new Error('Copy command failed');
                    }
                }
                
                // Show success feedback
                button.title = 'Copied!';
                button.style.color = '#10b981';
                
                // Reset after 2 seconds
                setTimeout(() => {
                    button.title = originalTitle;
                    button.style.color = '';
                }, 2000);
                
                // Success - no need to log
                
            } catch (error) {
                console.error('Failed to copy note:', error);
                
                // Show a more user-friendly fallback
                const copyText = fullText;
                
                // Create a temporary modal for copying
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                modal.innerHTML = `
                    <div style="
                        background: white;
                        padding: 20px;
                        border-radius: 8px;
                        max-width: 500px;
                        max-height: 400px;
                        overflow-y: auto;
                        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                    ">
                        <h3 style="margin: 0 0 15px 0; color: #374151;">Copy Note Content</h3>
                        <p style="margin: 0 0 10px 0; color: #6b7280; font-size: 14px;">Select and copy the text below:</p>
                        <textarea readonly style="
                            width: 100%;
                            height: 200px;
                            padding: 10px;
                            border: 1px solid #d1d5db;
                            border-radius: 4px;
                            font-family: inherit;
                            font-size: 14px;
                            resize: vertical;
                        ">${copyText}</textarea>
                        <div style="margin-top: 15px; text-align: right;">
                            <button onclick="this.closest('.modal').remove()" style="
                                background: #3b82f6;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 4px;
                                cursor: pointer;
                            ">Close</button>
                        </div>
                    </div>
                `;
                
                modal.className = 'modal';
                document.body.appendChild(modal);
                
                // Auto-select the text
                const textarea = modal.querySelector('textarea');
                textarea.focus();
                textarea.select();
            }
        }
        
        function showUploadProgress(title, fileSize, fileSizeMB) {
            // Create progress overlay
            const progressOverlay = document.createElement('div');
            progressOverlay.id = 'upload-progress-overlay';
            progressOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const isLargeFile = fileSize > 10 * 1024 * 1024; // > 10MB
            
            progressOverlay.innerHTML = `
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
                ">
                    <div style="margin-bottom: 20px;">
                        <div style="
                            width: 60px;
                            height: 60px;
                            border: 4px solid #e5e7eb;
                            border-top: 4px solid #3b82f6;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                            margin: 0 auto 20px;
                        "></div>
                        <h3 style="margin: 0 0 10px; color: #1f2937; font-size: 18px;">Processing ${title}</h3>
                        <p style="margin: 0; color: #6b7280; font-size: 14px;">File size: ${fileSizeMB} MB</p>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <div style="
                            width: 100%;
                            height: 8px;
                            background: #e5e7eb;
                            border-radius: 4px;
                            overflow: hidden;
                        ">
                            <div id="upload-progress-bar" style="
                                width: 0%;
                                height: 100%;
                                background: linear-gradient(90deg, #3b82f6, #1d4ed8);
                                transition: width 0.3s ease;
                            "></div>
                        </div>
                        <div id="upload-progress-text" style="
                            margin-top: 10px;
                            font-size: 14px;
                            color: #3b82f6;
                            font-weight: 500;
                        ">Starting upload...</div>
                    </div>
                    
                    <div id="upload-details" style="
                        background: #f9fafb;
                        border-radius: 8px;
                        padding: 15px;
                        text-align: left;
                        font-size: 12px;
                        color: #6b7280;
                        max-height: 200px;
                        overflow-y: auto;
                    ">
                        <div style="margin-bottom: 8px;"><strong>Console Log:</strong></div>
                        <div id="upload-console-log" style="font-family: monospace; white-space: pre-wrap;"></div>
                    </div>
                    
                    ${isLargeFile ? `
                        <div style="
                            margin-top: 15px;
                            padding: 10px;
                            background: #fef3c7;
                            border: 1px solid #f59e0b;
                            border-radius: 6px;
                            font-size: 12px;
                            color: #92400e;
                        ">
                            ⏳ Large file detected - this may take several minutes to process
                        </div>
                    ` : ''}
                </div>
                
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            
            document.body.appendChild(progressOverlay);
            
            // Add console logging
            const originalLog = console.log;
            const consoleLog = document.getElementById('upload-console-log');
            
            console.log = function(...args) {
                originalLog.apply(console, args);
                const timestamp = new Date().toLocaleTimeString();
                const message = args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
                ).join(' ');
                consoleLog.textContent += `[${timestamp}] ${message}\n`;
                consoleLog.scrollTop = consoleLog.scrollHeight;
            };
        }
        
        function updateUploadProgress(stage, message, progress = null) {
            const progressText = document.getElementById('upload-progress-text');
            const progressBar = document.getElementById('upload-progress-bar');
            
            if (progressText) {
                progressText.textContent = message;
            }
            
            if (progressBar && progress !== null) {
                progressBar.style.width = `${progress}%`;
            } else if (progressBar) {
                // Auto-progress based on stage
                const stageProgress = {
                    'uploading': 25,
                    'processing': 50,
                    'chunking': 75,
                    'completed': 100,
                    'error': 0
                };
                progressBar.style.width = `${stageProgress[stage] || 0}%`;
            }
            
            // Auto-hide on completion or error after delay
            if (stage === 'completed') {
                setTimeout(() => {
                    const overlay = document.getElementById('upload-progress-overlay');
                    if (overlay) overlay.remove();
                }, 3000);
            } else if (stage === 'error') {
                setTimeout(() => {
                    const overlay = document.getElementById('upload-progress-overlay');
                    if (overlay) overlay.remove();
                }, 10000);
            }
        }
        
        async function showNoteInContext(sourceId, sourceTitle, chunkIndex, noteContent = null) {
            console.log(`Loading notes in context for: ${sourceTitle}, chunk: ${chunkIndex}`);
            console.log('showNoteInContext called with:', { sourceId, sourceTitle, chunkIndex, noteContent });
            
            // Show the source viewer
            const sourceViewer = document.getElementById('source-viewer');
            const titleElement = document.getElementById('source-viewer-title');
            const contentElement = document.getElementById('source-viewer-content');
            
            // Update title
            titleElement.textContent = `Notes from ${sourceTitle}`;
            
            // Show loading state
            contentElement.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                    </div>
                    <div class="empty-title">Loading notes...</div>
                    <div class="empty-description">Fetching notes from ${sourceTitle}</div>
                </div>
            `;
            
            sourceViewer.classList.add('active');
            
            try {
                // Get all notes from this specific source
                const response = await fetch(`${API_BASE}/sources/${sourceId}/notes`);
                
                if (!response.ok) {
                    throw new Error(`Failed to get source notes: ${response.status}`);
                }
                
                const sourceNotes = await response.json();
                
                if (sourceNotes.length === 0) {
                    contentElement.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                                </svg>
                            </div>
                            <div class="empty-title">No notes found</div>
                            <div class="empty-description">No notes available for ${sourceTitle}</div>
                        </div>
                    `;
                    return;
                }
                
                // Sort by chunk_index to show in order
                sourceNotes.sort((a, b) => a.chunk_index - b.chunk_index);
                
                // Display notes with pagination
                contentElement.innerHTML = '';
                
                // Find the target note index - try by chunk_index first, then by content
                let targetNoteIndex = sourceNotes.findIndex(note => note.chunk_index === chunkIndex);
                console.log('Target note search by chunk_index:', { chunkIndex, targetNoteIndex, totalNotes: sourceNotes.length });
                
                // If not found by chunk_index, try to find by content (fallback for data inconsistency)
                if (targetNoteIndex === -1 && noteContent) {
                    console.log('Note not found by chunk_index, trying content matching...');
                    targetNoteIndex = sourceNotes.findIndex(note => 
                        note.content.trim() === noteContent.trim() || 
                        note.content.includes(noteContent.substring(0, 50))
                    );
                    console.log('Content matching result:', targetNoteIndex);
                }
                
                // Calculate how many notes to show initially to include the target note
                let initialCount = 20;
                if (targetNoteIndex >= 0 && targetNoteIndex >= 20) {
                    // If target note is beyond first 20, show more notes to include it
                    initialCount = Math.min(targetNoteIndex + 10, sourceNotes.length);
                }
                console.log('Initial count calculated:', initialCount);
                
                // Show initial notes
                const notesToShow = sourceNotes.slice(0, initialCount);
                const hasMore = sourceNotes.length > initialCount;
                
                notesToShow.forEach((note, index) => {
                    const noteCard = createNoteCard(note, false); // Hide context button in source notes panel
                    // Add highlighting for the specific note - check if this note matches the target chunk_index
                    if (targetNoteIndex >= 0 && note.chunk_index === chunkIndex) {
                        console.log('Highlighting note at index:', index, 'with chunk_index:', note.chunk_index);
                        noteCard.classList.add('highlighted-note');
                        noteCard.style.background = '#f0f9ff';
                        noteCard.style.border = '2px solid #3b82f6';
                    }
                    contentElement.appendChild(noteCard);
                });
                
                // Add "Show More" button if there are more notes
                if (hasMore) {
                    const loadMoreBtn = document.createElement('button');
                    loadMoreBtn.id = 'source-load-more-btn';
                    loadMoreBtn.className = 'load-more-btn';
                    loadMoreBtn.textContent = `Show More Notes (${sourceNotes.length - initialCount} remaining)`;
                    loadMoreBtn.onclick = () => loadMoreSourceNotes(sourceNotes, initialCount);
                    contentElement.appendChild(loadMoreBtn);
                }
                
                // Scroll to the specific note
                setTimeout(() => {
                    const targetNote = contentElement.querySelector('.highlighted-note');
                    console.log('Looking for highlighted note:', targetNote);
                    if (targetNote) {
                        console.log('Scrolling to highlighted note');
                        targetNote.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    } else {
                        console.log('No highlighted note found');
                    }
                }, 100);
                
            } catch (error) {
                console.error('Error loading source notes:', error);
                contentElement.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                        </div>
                        <div class="empty-title">Error Loading Notes</div>
                        <div class="empty-description">Could not load notes from ${sourceTitle}</div>
                    </div>
                `;
            }
        }
        
        function loadMoreSourceNotes(allNotes, currentCount) {
            const contentElement = document.getElementById('source-viewer-content');
            const loadMoreBtn = document.getElementById('source-load-more-btn');
            
            // Load next 20 notes
            const nextBatch = allNotes.slice(currentCount, currentCount + 20);
            const remaining = allNotes.length - (currentCount + 20);
            
            nextBatch.forEach(note => {
                const noteCard = createNoteCard(note, false); // Hide context button in source notes panel
                contentElement.insertBefore(noteCard, loadMoreBtn);
            });
            
            // Update button or remove it
            if (remaining > 0) {
                loadMoreBtn.textContent = `Show More Notes (${remaining} remaining)`;
                loadMoreBtn.onclick = () => loadMoreSourceNotes(allNotes, currentCount + 20);
            } else {
                loadMoreBtn.remove();
            }
        }
        
        async function showSourceNotesFromLibrary(sourceId, sourceTitle) {
            console.log(`Loading notes for source: ${sourceTitle}`);
            
            // Check if this is a temporary ID (still processing)
            if (sourceId.startsWith('temp-')) {
                const sourceCard = document.getElementById(`source-${sourceId}`);
                if (sourceCard) {
                    const statusBadge = sourceCard.querySelector('.status-badge');
                    if (statusBadge && statusBadge.textContent.includes('Processing')) {
                        // Show processing message instead of error
                        const sourceViewer = document.getElementById('source-viewer');
                        const titleElement = document.getElementById('source-viewer-title');
                        const contentElement = document.getElementById('source-viewer-content');
                        
                        titleElement.textContent = `Notes from ${sourceTitle}`;
                        contentElement.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-icon">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                </div>
                                <div class="empty-title">Still Processing</div>
                                <div class="empty-description">Please wait for the upload to complete before viewing notes.</div>
                            </div>
                        `;
                        sourceViewer.classList.add('active');
                        return;
                    }
                }
            }
            
            // Show the source viewer
            const sourceViewer = document.getElementById('source-viewer');
            const titleElement = document.getElementById('source-viewer-title');
            const contentElement = document.getElementById('source-viewer-content');
            
            // Update title
            titleElement.textContent = `Notes from ${sourceTitle}`;
            
            // Show loading state
            contentElement.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                    </div>
                    <div class="empty-title">Loading notes...</div>
                    <div class="empty-description">Fetching notes from ${sourceTitle}</div>
                </div>
            `;
            
            sourceViewer.classList.add('active');
            
            try {
                // Get all notes from this specific source
                const response = await fetch(`${API_BASE}/sources/${sourceId}/notes`);
                
                if (!response.ok) {
                    throw new Error(`Failed to get source notes: ${response.status}`);
                }
                
                const sourceNotes = await response.json();
                
                if (sourceNotes.length === 0) {
                    contentElement.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                                </svg>
                            </div>
                            <div class="empty-title">No notes found</div>
                            <div class="empty-description">No notes available for ${sourceTitle}</div>
                        </div>
                    `;
                    return;
                }
                
                // Sort by chunk_index to show in order
                sourceNotes.sort((a, b) => a.chunk_index - b.chunk_index);
                
                // Display notes with pagination
                contentElement.innerHTML = '';
                
                // Show first 20 notes initially
                const notesToShow = sourceNotes.slice(0, 20);
                const hasMore = sourceNotes.length > 20;
                
                notesToShow.forEach(note => {
                    const noteCard = createNoteCard(note, false); // Hide context button in source notes panel
                    contentElement.appendChild(noteCard);
                });
                
                // Add "Show More" button if there are more notes
                if (hasMore) {
                    const loadMoreBtn = document.createElement('button');
                    loadMoreBtn.id = 'source-load-more-btn';
                    loadMoreBtn.className = 'load-more-btn';
                    loadMoreBtn.textContent = `Show More Notes (${sourceNotes.length - 20} remaining)`;
                    loadMoreBtn.onclick = () => loadMoreSourceNotes(sourceNotes, 20);
                    contentElement.appendChild(loadMoreBtn);
                }
                
                console.log(`Loaded ${sourceNotes.length} notes from ${sourceTitle}`);
                
            } catch (error) {
                console.error('Error loading source notes:', error);
                contentElement.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                        </div>
                        <div class="empty-title">Error Loading Notes</div>
                        <div class="empty-description">Could not load notes from ${sourceTitle}</div>
                    </div>
                `;
            }
        }
        
        function displayEmptyState() {
            const resultsContainer = document.getElementById('notes-results');
            resultsContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                        </svg>
                    </div>
                    <div class="empty-title">No notes yet</div>
                    <div class="empty-description">Search or start writing to see relevant notes</div>
                </div>
            `;
        }
        
        function displayErrorState() {
            const resultsContainer = document.getElementById('notes-results');
            resultsContainer.innerHTML = `
                <div class="empty-state">
                    <div class="empty-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                        </svg>
                    </div>
                    <div class="empty-title">Search Error</div>
                    <div class="empty-description">Could not perform search. Please try again.</div>
                </div>
            `;
        }
        
        function showUploadInterface() {
            console.log('Showing upload interface');
            document.getElementById('upload-form').style.display = 'block';
        }
        
        function hideUploadInterface() {
            document.getElementById('upload-form').style.display = 'none';
            document.getElementById('upload-title').value = '';
            document.getElementById('upload-author').value = '';
            document.getElementById('upload-status').innerHTML = '';
            document.getElementById('selected-file').style.display = 'none';
            document.getElementById('upload-btn').disabled = true;
            selectedFile = null;
            
            // Reset file input
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                fileInput.value = '';
            }
        }
        
        function handleFileSelection(file) {
            console.log('handleFileSelection called with:', file);
            if (!file) {
                console.log('No file provided to handleFileSelection');
                return;
            }
            
            console.log('Setting selectedFile to:', file.name, file.size, file.type);
            selectedFile = file;
            
            // Show selected file info
            const fileInfo = document.getElementById('selected-file');
            fileInfo.innerHTML = `
                <strong>Selected:</strong> ${file.name} 
                <span style="color: #6b7280;">(${(file.size / 1024).toFixed(1)} KB)</span>
            `;
            fileInfo.style.display = 'block';
            
            // Auto-fill title if empty
            const titleInput = document.getElementById('upload-title');
            if (!titleInput.value) {
                const fileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
                titleInput.value = fileName;
            }
            
            // Enable upload button
            document.getElementById('upload-btn').disabled = false;
        }
        
        async function processUpload() {
            const title = document.getElementById('upload-title').value.trim();
            const author = document.getElementById('upload-author').value.trim();
            const statusDiv = document.getElementById('upload-status');
            const uploadBtn = document.getElementById('upload-btn');
            
            // Disable button immediately to prevent double-clicks
            uploadBtn.disabled = true;
            
            if (!title) {
                statusDiv.innerHTML = '<span style="color: #dc2626;">Please enter a title</span>';
                uploadBtn.disabled = false;
                return;
            }
            
            if (!selectedFile) {
                statusDiv.innerHTML = '<span style="color: #dc2626;">Please select a file</span>';
                uploadBtn.disabled = false;
                return;
            }
            
            console.log('Selected file:', selectedFile);
            console.log('File name:', selectedFile?.name);
            console.log('File size:', selectedFile?.size);
            console.log('File type:', selectedFile?.type);
            
            // Double-check that we have a valid file
            if (!selectedFile || !selectedFile.name || !selectedFile.size) {
                statusDiv.innerHTML = '<span style="color: #dc2626;">Invalid file selected. Please try again.</span>';
                uploadBtn.disabled = false;
                return;
            }
            
            const tempId = 'temp-' + Date.now();
            
            // Store file info before hiding interface
            const fileSize = selectedFile.size;
            const fileName = selectedFile.name.toLowerCase();
            const fileType = selectedFile.type;
            const fileSizeMB = (fileSize / (1024 * 1024)).toFixed(1);
            
            // For binary files, prepare the file content before clearing selectedFile
            let fileContent = null;
            let isBinaryFile = false;
            
            if (fileName.endsWith('.pdf') || fileName.endsWith('.epub')) {
                isBinaryFile = true;
                console.log('Preparing binary file:', fileName, 'Size:', fileSize);
                updateUploadProgress('processing', 'Preparing file for upload...');
                
                const arrayBuffer = await selectedFile.arrayBuffer();
                console.log('ArrayBuffer created, size:', arrayBuffer.byteLength);
                
                // Convert to base64 in chunks to avoid stack overflow
                const uint8Array = new Uint8Array(arrayBuffer);
                let binaryString = '';
                const chunkSize = 8192; // Process in 8KB chunks
                
                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const chunk = uint8Array.slice(i, i + chunkSize);
                    binaryString += String.fromCharCode.apply(null, chunk);
                }
                
                fileContent = btoa(binaryString);
                console.log('File converted to base64, length:', fileContent.length);
            }
            
            // Show detailed progress UI
            showUploadProgress(title, fileSize, fileSizeMB);
            
            // Set up timeout for large files (30 minutes)
            const uploadTimeout = setTimeout(() => {
                updateUploadProgress('error', 'Upload timeout - file may be too large or complex');
            }, 30 * 60 * 1000); // 30 minutes
            
            try {
                // Use the stored selectedFile instead of reading from file input
                console.log('Using stored selectedFile:', selectedFile);
                
                if (!selectedFile) {
                    throw new Error('No file selected - please select a file first');
                }
                
                const file = selectedFile;
                console.log('Selected file details:', {
                    name: file.name,
                    size: file.size,
                    type: file.type
                });
                
                let sourceType = 'txt';
                // fileContent already prepared above for binary files
                
                if (fileName.endsWith('.json')) {
                    // Check if it's a Roam Research JSON by looking at the file content
                    fileContent = await file.text();
                    try {
                        const jsonData = JSON.parse(fileContent);
                        // Roam Research exports are arrays of pages with specific structure
                        if (Array.isArray(jsonData) && jsonData.length > 0 && 
                            jsonData[0].hasOwnProperty('title') && 
                            jsonData[0].hasOwnProperty('children')) {
                            sourceType = 'roam';
                            console.log('Detected Roam Research JSON format');
                        } else {
                            sourceType = 'json';
                            console.log('Detected generic JSON format');
                        }
                    } catch (e) {
                        sourceType = 'json';
                        console.log('Invalid JSON, treating as generic');
                    }
                } else if (fileName.endsWith('.pdf')) {
                    sourceType = 'pdf';
                } else if (fileName.endsWith('.epub')) {
                    sourceType = 'epub';
                }
                
                const tempId = 'temp-' + Date.now();
                
                addSourceToUI({
                    id: tempId,
                    title: title,
                    author: author || 'Unknown Author',
                    source_type: sourceType,
                    status: 'processing'
                });
                
                // Update progress to uploading
                updateUploadProgress('uploading', 'Uploading file to server...');
                console.log(`Starting upload: ${title} (${fileSizeMB} MB)`);
                
                // Prepare upload data based on file type
                let uploadData = {
                    title: title,
                    author: author || 'Unknown Author',
                    source_type: sourceType
                };
                
                if (isBinaryFile) {
                    // Use the pre-prepared base64 content
                    console.log('Using pre-prepared binary file:', fileName, 'Size:', fileSize);
                    updateUploadProgress('processing', 'Preparing binary file for upload...');
                    uploadData.file_buffer = fileContent;
                } else {
                    // For text files, we need to get the file content
                    updateUploadProgress('processing', 'Reading text file...');
                    
                    let content;
                    if (fileContent) {
                        // Reuse content we already read for JSON detection
                        content = fileContent;
                        console.log('Reusing previously read content, length:', content.length);
                    } else {
                        // Read file content for non-JSON files
                        content = await file.text();
                        console.log('Text file read, length:', content.length);
                    }
                    uploadData.content = content;
                }
                
                updateUploadProgress('uploading', 'Sending to server...');
                console.log('Sending upload request to server...');
                
                const response = await fetch(`${API_BASE}/upload-source`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(uploadData)
                });
                
                console.log('Server response received:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Upload failed: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Upload successful:', result);
                
                updateSourceStatus(tempId, {
                    id: result.source_id,
                    chunks_created: result.chunks_created,
                    processing_status: result.status
                });
                
                // Small delay to ensure UI is updated before user can interact
                setTimeout(() => {
                    // Show success message based on status
                    console.log('Upload result status:', result.status);
                    if (result.status === 'pending_review') {
                        console.log('Starting automatic embedding generation...');
                        updateUploadProgress('processing', `🤖 Processing your document... Generating embeddings in progress.`);
                        
                        // Automatically start embedding generation
                        setTimeout(async () => {
                            try {
                                console.log('Triggering embedding generation for source:', result.source_id);
                                updateUploadProgress('processing', `🤖 Generating embeddings... This may take a few minutes.`);
                                
                                const completeResponse = await fetch(`${API_BASE}/complete-source-processing`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ source_id: result.source_id })
                                });
                                
                                console.log('Complete response status:', completeResponse.status);
                                console.log('Complete response ok:', completeResponse.ok);
                                
                                if (completeResponse.ok) {
                                    const completeResult = await completeResponse.json();
                                    console.log('Embedding generation completed:', completeResult);
                                    updateUploadProgress('completed', `✓ Processing complete! ${completeResult.chunks_created} chunks ready for search.`);
                                    
                                    // Update the source status in the UI
                                    updateSourceStatus(result.source_id, {
                                        processing_status: 'completed',
                                        chunks_created: completeResult.chunks_created
                                    });
                                } else {
                                    const errorText = await completeResponse.text();
                                    console.error('Error completing processing:', completeResponse.status, completeResponse.statusText, errorText);
                                    updateUploadProgress('error', `❌ Error completing processing. Please try again.`);
                                }
                            } catch (error) {
                                console.error('Error completing processing:', error);
                                updateUploadProgress('error', `❌ Error completing processing. Please try again.`);
                            }
                        }, 2000); // Wait 2 seconds before starting embedding generation
                    } else {
                        console.log('Upload completed without processing needed');
                        updateUploadProgress('completed', `✓ Upload completed successfully! Created ${result.chunks_created} notes.`);
                    }
                    // Hide upload form after successful upload
                    hideUploadInterface();
                    // Refresh the source list to show the new source with correct status
                    loadSourcesFromBackend();
                }, 100);
                
                clearTimeout(uploadTimeout);
                
            } catch (error) {
                console.error('Upload error:', error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                clearTimeout(uploadTimeout);
                
                // Show detailed error message
                let errorMessage = 'Upload failed';
                if (error.message.includes('timeout')) {
                    errorMessage = 'Upload timeout - file may be too large or complex';
                } else if (error.message.includes('413')) {
                    errorMessage = 'File too large - please try a smaller file';
                } else if (error.message.includes('500')) {
                    errorMessage = 'Server error - file may be corrupted or unsupported';
                } else {
                    errorMessage = `Upload failed: ${error.message}`;
                }
                
                updateUploadProgress('error', errorMessage);
                
                // Hide upload form after error
                hideUploadInterface();
                
                // Only try to update source status if tempId exists
                if (typeof tempId !== 'undefined') {
                    updateSourceStatus(tempId, {
                        status: 'error',
                        error: error.message
                    });
                }
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload & Process';
            }
        }
        
        async function deleteSource(sourceId, sourceTitle) {
            if (!confirm(`Are you sure you want to delete "${sourceTitle}"?`)) {
                return;
            }
            
            const sourceCard = document.getElementById(`source-${sourceId}`);
            if (sourceCard) {
                sourceCard.style.opacity = '0.5';
                sourceCard.style.pointerEvents = 'none';
            }
            
            try {
                const response = await fetch(`${API_BASE}/sources/${sourceId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error(`Delete failed: ${response.status}`);
                }
                
                if (sourceCard) {
                    sourceCard.remove();
                }
                
                const sourcesList = document.getElementById('sources-list');
                if (sourcesList.children.length === 0) {
                    sourcesList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                                </svg>
                            </div>
                            <div class="empty-title">No sources yet</div>
                            <div class="empty-description">Upload your first source to get started</div>
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Delete error:', error);
                if (sourceCard) {
                    sourceCard.style.opacity = '1';
                    sourceCard.style.pointerEvents = 'auto';
                }
            }
        }
        
        async function loadSourcesFromBackend() {
            const sourcesList = document.getElementById('sources-list');
            
            try {
                const response = await fetch(`${API_BASE}/sources`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const sources = await response.json();
                sourcesList.innerHTML = '';
                
                if (sources.length === 0) {
                    sourcesList.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                                </svg>
                            </div>
                            <div class="empty-title">No sources yet</div>
                            <div class="empty-description">Upload your first source to get started</div>
                        </div>
                    `;
                } else {
                        sources.forEach(source => {
                            addSourceToUI({
                                id: source.id,
                                title: source.title,
                                author: source.author,
                                source_type: source.source_type,
                                processing_status: source.processing_status,
                                chunks_created: source.chunk_count,
                                chunk_count: source.chunk_count
                            });
                        });
                }
                
            } catch (error) {
                console.error('Error loading sources:', error);
                sourcesList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                        </div>
                        <div class="empty-title">Connection Error</div>
                        <div class="empty-description">Could not load sources. Is your backend running?</div>
                    </div>
                `;
            }
        }
        
        function addSourceToUI(source) {
            const sourcesList = document.getElementById('sources-list');
            
            const emptyState = sourcesList.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            const sourceCard = document.createElement('div');
            sourceCard.className = 'source-card';
            sourceCard.id = `source-${source.id}`;
            
            const statusBadge = getStatusBadge(source.processing_status, { chunks_created: source.chunks_created, chunk_count: source.chunk_count });
            const icon = getSourceIcon(source.source_type);
            
            sourceCard.innerHTML = `
                <div class="source-header">
                    <div class="source-icon">${icon}</div>
                    <div class="source-info">
                        <div class="source-title">${source.title}</div>
                        <div class="source-author">${source.author}</div>
                    </div>
                    ${statusBadge}
                </div>
                <div class="source-actions" style="display: ${source.processing_status === 'processing' ? 'none' : 'flex'};">
                    <button class="source-action-btn" onclick="showSourceNotesFromLibrary('${source.id}', '${source.title}')">Notes</button>
                    <button class="source-action-btn" onclick="showSourceDetails('${source.id}', '${source.title}', '${source.author}')">Details</button>
                    <button class="source-action-btn delete" onclick="deleteSource('${source.id}', '${source.title}')">Delete</button>
                </div>
            `;

            sourcesList.insertBefore(sourceCard, sourcesList.firstChild);
        }
        
        function updateSourceStatus(tempId, updateData) {
            // First try to find by tempId, then by real ID if updateData.id is provided
            let sourceCard = document.getElementById(`source-${tempId}`);
            if (!sourceCard && updateData.id) {
                sourceCard = document.getElementById(`source-${updateData.id}`);
            }
            if (!sourceCard) return;
            
            if (updateData.id && updateData.id !== tempId) {
                sourceCard.id = `source-${updateData.id}`;
            }
            
            if (updateData.processing_status) {
                const statusBadge = getStatusBadge(updateData.processing_status, updateData);
                const existingBadge = sourceCard.querySelector('.status-badge');
                if (existingBadge) {
                    existingBadge.outerHTML = statusBadge;
                }
            }
            
            const actionsDiv = sourceCard.querySelector('.source-actions');
            if (actionsDiv && updateData.processing_status) {
                actionsDiv.style.display = updateData.processing_status === 'processing' ? 'none' : 'flex';
            }
        }
        
        function getStatusBadge(status, data = {}) {
            let badgeClass = 'status-badge';
            let badgeText = '';
            
            switch (status) {
                case 'processing':
                    badgeClass += ' processing';
                    badgeText = 'Processing...';
                    break;
                case 'pending_review':
                    badgeClass += ' processing';
                    badgeText = 'Processing...';
                    break;
                case 'completed':
                case 'uploaded':
                    badgeText = `${data.chunks_created || data.chunk_count || 0} notes`;
                    break;
                case 'error':
                    badgeClass += ' error';
                    badgeText = 'Error';
                    break;
                default:
                    return '';
            }
            
            return `<div class="${badgeClass}">${badgeText}</div>`;
        }
        
        function getSourceIcon(sourceType) {
            switch (sourceType) {
                case 'txt': 
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>';
                case 'json': 
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" /></svg>';
                case 'pdf': 
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>';
                case 'epub':
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>';
                case 'docx':
                case 'doc':
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>';
                case 'md':
                case 'markdown':
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" /></svg>';
                default: 
                    return '<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>';
            }
        }
        
        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }
        
        // Initialize search functionality
        function initializeSearch() {
            console.log('Initializing search functionality...');
            
            // Set initial search mode
            searchMode = 'smart';
            autoSearchEnabled = true;
            
            // Update UI to reflect current state
            const smartSearchRadio = document.querySelector('input[name="search-mode"][value="smart"]');
            const textSearchRadio = document.querySelector('input[name="search-mode"][value="text"]');
            const autoSearchToggle = document.getElementById('auto-search-toggle');
            
            if (smartSearchRadio) smartSearchRadio.checked = true;
            if (textSearchRadio) textSearchRadio.checked = false;
            if (autoSearchToggle) autoSearchToggle.checked = true;
            
            // Set initial placeholder
            const searchInput = document.getElementById('notes-search');
            if (searchInput) {
                searchInput.placeholder = 'Smart search with semantic understanding';
            }
            
            console.log('Search initialized - mode:', searchMode, 'auto-search:', autoSearchEnabled);
        }
        
        // File input handling
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize projects
            await initializeProjects();
            
            // Initialize search mode and auto-search
            initializeSearch();
            
            // Initialize textarea auto-resize
            const searchTextarea = document.getElementById('notes-search');
            if (searchTextarea) {
                autoResizeTextarea(searchTextarea);
            }
            
            // Add auto-save for title
            const titleInput = document.getElementById('document-title');
            if (titleInput) {
                titleInput.addEventListener('input', updateProjectContent);
            }
            
            const fileInput = document.getElementById('file-input');
            const dropArea = document.querySelector('.file-drop-area');
            
            if (fileInput && dropArea) {
                fileInput.addEventListener('change', function(e) {
                    handleFileSelection(e.target.files[0]);
                });
                
                dropArea.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    dropArea.classList.add('dragover');
                });
                
                dropArea.addEventListener('dragleave', function(e) {
                    e.preventDefault();
                    dropArea.classList.remove('dragover');
                });
                
                dropArea.addEventListener('drop', function(e) {
                    e.preventDefault();
                    dropArea.classList.remove('dragover');
                    handleFileSelection(e.dataTransfer.files[0]);
                });
            }
            
            console.log('Research Assistant loaded successfully');
        });
        
        // Make functions globally accessible
        window.switchToPanel = switchToPanel;
        window.showUploadInterface = showUploadInterface;
        window.hideUploadInterface = hideUploadInterface;
        window.processUpload = processUpload;
        window.deleteSource = deleteSource;
        window.performSearch = performSearch;
        window.performAutoSearch = performAutoSearch;
        window.loadMoreResults = loadMoreResults;
        window.applyFilters = applyFilters;
        window.toggleSaveNote = toggleSaveNote;
        window.showSourceNotes = showSourceNotes;
        window.showSourceNotesFromLibrary = showSourceNotesFromLibrary;
        window.createNoteCard = createNoteCard;
        window.handleEditorInput = handleEditorInput;
        window.toggleAutoSearch = toggleAutoSearch;
        window.toggleSearchMode = toggleSearchMode;
        window.showCreateProjectModal = showCreateProjectModal;
        window.hideCreateProjectModal = hideCreateProjectModal;
        window.createNewProject = createNewProject;
        window.deleteProject = deleteProject;
        window.hideDeleteProjectModal = hideDeleteProjectModal;
        window.confirmDeleteProject = confirmDeleteProject;
        window.loadProject = loadProject;
        window.toggleSidebar = toggleSidebar;
        window.togglePanel = togglePanel;
        window.expandSidebar = expandSidebar;
        window.showNoteInContext = showNoteInContext;
        window.copyNoteContent = copyNoteContent;
        
        // Test function to verify copyNoteContent works
        window.testCopy = function() {
            console.log('Testing copy function...');
            copyNoteContent('Test content', 'Test Source', 'Test Author', document.querySelector('.note-action-btn'));
        };
        
        // Test function to verify search works
        window.testSearch = function(query = 'grace of God') {
            console.log('Testing search with query:', query);
            document.getElementById('notes-search').value = query;
            performSearch();
        };
        
        // Simple test function to verify onclick works
        window.testClick = function() {
            alert('Button click works!');
        };
        window.loadMoreSourceNotes = loadMoreSourceNotes;
        window.showUploadProgress = showUploadProgress;
        window.updateUploadProgress = updateUploadProgress;
        window.handleSearchKeydown = handleSearchKeydown;
        window.performManualSearch = performManualSearch;
        window.closeSourceViewer = closeSourceViewer;
        window.showSourceDetails = showSourceDetails;
        window.hideSourceDetails = hideSourceDetails;
        window.saveSourceDetails = saveSourceDetails;
        
        // Review Interface Functions
        let currentReviewSourceId = null;
        let currentReviewChunks = [];
        
        async function viewAICurationStatus(sourceId, sourceTitle) {
            console.log(`Viewing AI curation status for source: ${sourceTitle}`);
            currentReviewSourceId = sourceId;
            
            // Hide project draft panel
            const projectDraft = document.querySelector('.writing-area');
            if (projectDraft) {
                projectDraft.style.display = 'none';
            }
            
            // Show review interface
            const reviewInterface = document.getElementById('review-interface');
            const reviewTitle = document.getElementById('review-title');
            const reviewContent = document.getElementById('review-content');
            
            reviewTitle.textContent = `AI Curation Status - ${sourceTitle}`;
            reviewInterface.classList.add('active');
            
            // Show loading state
            reviewContent.innerHTML = `
                <div class="empty-review">
                    <div class="empty-review-icon">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                    </div>
                    <div class="empty-title">Loading chunks...</div>
                    <div class="empty-description">Fetching chunks for review</div>
                </div>
            `;
            
            try {
                // Fetch chunks for review
                const response = await fetch(`${API_BASE}/sources/${sourceId}/chunks-for-review`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch chunks: ${response.status}`);
                }
                
                currentReviewChunks = await response.json();
                
                if (currentReviewChunks.length === 0) {
                    reviewContent.innerHTML = `
                        <div class="empty-review">
                            <div class="empty-review-icon">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                </svg>
                            </div>
                            <div class="empty-title">No chunks found</div>
                            <div class="empty-description">This source has no chunks ready for review</div>
                        </div>
                    `;
                    return;
                }
                
                // Render chunks
                renderReviewChunks();
                
            } catch (error) {
                console.error('Error loading chunks for review:', error);
                reviewContent.innerHTML = `
                    <div class="empty-review">
                        <div class="empty-review-icon">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
                            </svg>
                        </div>
                        <div class="empty-title">Error loading chunks</div>
                        <div class="empty-description">${error.message}</div>
                    </div>
                `;
            }
        }
        
        function renderReviewChunks() {
            const reviewContent = document.getElementById('review-content');

            const statsHtml = `
                <div class="review-stats">
                    <strong>${currentReviewChunks.length}</strong> notes ready for review
                </div>
            `;

            const chunksHtml = currentReviewChunks.map((chunk, index) => {
                const isHeading = chunk.heading_level === 'h1' || chunk.heading_level === 'h2' || chunk.heading_level === 'h3' || chunk.heading_level === 'h4';
                return `
                <div class="chunk-card ${isHeading ? 'heading' : ''}" data-chunk-id="${chunk.id}">
                    <div class="chunk-header">
                        <div class="chunk-index">${isHeading ? 'Heading' : 'Note'} ${chunk.chunk_index + 1}</div>
                        <div class="chunk-actions">
                            <button class="chunk-action-btn" onclick="splitChunk('${chunk.id}')" title="Split note">Split</button>
                            <button class="chunk-action-btn" onclick="deleteChunk('${chunk.id}')" title="Delete note" class="danger">Delete</button>
                        </div>
                    </div>
                    <textarea class="chunk-content" data-chunk-id="${chunk.id}" onblur="updateChunkContent('${chunk.id}')" oninput="autoResizeTextarea(this)">${chunk.content}</textarea>
                    ${chunk.structure_path && chunk.structure_path.trim() ? `
                    <div class="chunk-structure">
                        <input type="text" class="structure-path-input" value="${chunk.structure_path.replace(/\s*>\s*Chunk\s+\d+/g, '')}" data-chunk-id="${chunk.id}" onblur="updateStructurePath('${chunk.id}', this.value)" placeholder="Section name">
                    </div>
                    ` : `
                    <div class="chunk-structure" style="display: none;">
                        <input type="text" class="structure-path-input" value="" data-chunk-id="${chunk.id}" onblur="updateStructurePath('${chunk.id}', this.value)" placeholder="Section name">
                    </div>
                    `}
                </div>
            `;
            }).join('');

            reviewContent.innerHTML = statsHtml + chunksHtml;
            
            // Auto-resize all textareas after rendering
            const textareas = reviewContent.querySelectorAll('.chunk-content');
            textareas.forEach(textarea => autoResizeTextarea(textarea));
        }
        
        async function updateChunkContent(chunkId) {
            const textarea = document.querySelector(`textarea[data-chunk-id="${chunkId}"]`);
            const newContent = textarea.value;
            
            // Skip update for temporary chunks (new headings)
            if (chunkId.startsWith('temp-')) {
                const chunk = currentReviewChunks.find(c => c.id === chunkId);
                if (chunk) {
                    chunk.content = newContent;
                }
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/chunks/${chunkId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        content: newContent
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to update chunk: ${response.status}`);
                }
                
                // Update local data
                const chunk = currentReviewChunks.find(c => c.id === chunkId);
                if (chunk) {
                    chunk.content = newContent;
                }
                
                console.log(`Chunk ${chunkId} updated successfully`);
                
            } catch (error) {
                console.error('Error updating chunk:', error);
                alert(`Failed to update chunk: ${error.message}`);
            }
        }
        
        async function splitChunk(chunkId) {
            // Don't allow splitting temporary chunks
            if (chunkId.startsWith('temp-')) {
                alert('Cannot split new headings. Please complete the review first.');
                return;
            }
            
            const textarea = document.querySelector(`textarea[data-chunk-id="${chunkId}"]`);
            const content = textarea.value;
            const cursorPosition = textarea.selectionStart;
            
            if (cursorPosition === 0 || cursorPosition === content.length) {
                alert('Please position your cursor where you want to split the chunk');
                return;
            }
            
            // Save current scroll position
            const reviewContent = document.querySelector('.review-content');
            const scrollTop = reviewContent ? reviewContent.scrollTop : 0;
            
            try {
                const response = await fetch(`${API_BASE}/chunks/${chunkId}/split`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        splitIndex: cursorPosition
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to split chunk: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Update local data
                const chunkIndex = currentReviewChunks.findIndex(c => c.id === chunkId);
                if (chunkIndex !== -1) {
                    currentReviewChunks[chunkIndex] = result.originalChunk;
                    currentReviewChunks.splice(chunkIndex + 1, 0, result.newChunk);
                }
                
                // Re-render chunks
                renderReviewChunks();
                
                // Restore scroll position
                if (reviewContent) {
                    reviewContent.scrollTop = scrollTop;
                }
                
                console.log(`Chunk ${chunkId} split successfully`);
                
            } catch (error) {
                console.error('Error splitting chunk:', error);
                alert(`Failed to split chunk: ${error.message}`);
            }
        }
        
        async function deleteChunk(chunkId) {
            if (!confirm('Are you sure you want to delete this note?')) {
                return;
            }
            
            // Save current scroll position
            const reviewContent = document.querySelector('.review-content');
            const scrollTop = reviewContent ? reviewContent.scrollTop : 0;
            
            // Handle temporary chunks (new headings) - just remove from local data
            if (chunkId.startsWith('temp-')) {
                currentReviewChunks = currentReviewChunks.filter(c => c.id !== chunkId);
                // Reindex remaining chunks
                currentReviewChunks.forEach((chunk, index) => {
                    chunk.chunk_index = index;
                });
                renderReviewChunks();
                // Restore scroll position
                if (reviewContent) {
                    reviewContent.scrollTop = scrollTop;
                }
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/chunks/${chunkId}`, {
                    method: 'DELETE'
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to delete chunk: ${response.status}`);
                }
                
                // Update local data
                currentReviewChunks = currentReviewChunks.filter(c => c.id !== chunkId);
                
                // Re-render chunks
                renderReviewChunks();
                
                // Restore scroll position
                if (reviewContent) {
                    reviewContent.scrollTop = scrollTop;
                }
                
                console.log(`Chunk ${chunkId} deleted successfully`);
                
            } catch (error) {
                console.error('Error deleting chunk:', error);
                alert(`Failed to delete chunk: ${error.message}`);
            }
        }
        
        
        async function completeReview() {
            if (!currentReviewSourceId) {
                console.error('No source selected for review completion');
                return;
            }
            
            try {
                // First, save any new headings to the database
                const newHeadings = currentReviewChunks.filter(chunk => chunk.id.startsWith('temp-'));
                for (const heading of newHeadings) {
                    await saveNewHeading(heading);
                }
                
                // Close review interface immediately
                closeReviewInterface();
                
                // Update source status to processing
                const sourceCard = document.getElementById(`source-${currentReviewSourceId}`);
                if (sourceCard) {
                    const statusBadge = sourceCard.querySelector('.status-badge');
                    if (statusBadge) {
                        statusBadge.className = 'status-badge processing';
                        statusBadge.textContent = 'Processing...';
                    }
                }
                
                // Start processing in background
                const response = await fetch(`${API_BASE}/complete-source-processing`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_id: currentReviewSourceId
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to complete processing: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Refresh the source list to show final status
                loadSourcesFromBackend();
                
                // Show success message
                alert(`Source processing completed! ${result.chunks_created} notes processed.`);
                
                console.log('Source processing completed successfully');
                
            } catch (error) {
                console.error('Error completing review:', error);
                alert(`Failed to complete processing: ${error.message}`);
                
                // Refresh source list to show error status
                loadSourcesFromBackend();
            }
        }
        
        async function saveNewHeading(heading) {
            try {
                const response = await fetch(`${API_BASE}/chunks`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        source_id: heading.source_id,
                        content: heading.content,
                        chunk_index: heading.chunk_index,
                        structure_path: heading.structure_path,
                        heading_level: heading.heading_level
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to save heading: ${response.status}`);
                }
                
                const savedHeading = await response.json();
                
                // Update the local chunk with the real ID
                const localChunk = currentReviewChunks.find(c => c.id === heading.id);
                if (localChunk) {
                    localChunk.id = savedHeading.id;
                    localChunk.is_new = false;
                }
                
                console.log(`Heading saved with ID: ${savedHeading.id}`);
                
            } catch (error) {
                console.error('Error saving heading:', error);
                throw error;
            }
        }
        
        function closeReviewInterface() {
            const reviewInterface = document.getElementById('review-interface');
            reviewInterface.classList.remove('active');
            
            // Restore project draft panel
            const projectDraft = document.querySelector('.writing-area');
            if (projectDraft) {
                projectDraft.style.display = 'block';
            }
            
            currentReviewSourceId = null;
            currentReviewChunks = [];
        }

        function autoResizeTextarea(textarea) {
            // Reset height to auto to get the correct scrollHeight
            textarea.style.height = 'auto';
            // Set height to scrollHeight + a small buffer
            textarea.style.height = (textarea.scrollHeight + 2) + 'px';
        }


        async function updateStructurePath(chunkId, newPath) {
            // Find the current chunk
            const currentChunk = currentReviewChunks.find(c => c.id === chunkId);
            if (!currentChunk) return;
            
            const currentIndex = currentChunk.chunk_index;
            
            // Update all chunks from current index onwards
            const chunksToUpdate = currentReviewChunks.filter(c => c.chunk_index >= currentIndex);
            
            // Update local data first
            chunksToUpdate.forEach(chunk => {
                chunk.structure_path = newPath;
            });
            
            // Update in database (skip temporary chunks)
            for (const chunk of chunksToUpdate) {
                if (chunk.id.startsWith('temp-')) {
                    continue; // Skip temporary chunks
                }
                
                try {
                    const response = await fetch(`${API_BASE}/chunks/${chunk.id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            structure_path: newPath
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to update structure path: ${response.status}`);
                    }
                } catch (error) {
                    console.error(`Error updating structure path for chunk ${chunk.id}:`, error);
                    // Continue with other chunks even if one fails
                }
            }
            
            // Save current scroll position
            const reviewContent = document.querySelector('.review-content');
            const scrollTop = reviewContent ? reviewContent.scrollTop : 0;
            
            // Re-render to show changes
            renderReviewChunks();
            
            // Restore scroll position
            if (reviewContent) {
                reviewContent.scrollTop = scrollTop;
            }
            
            console.log(`Updated structure path for ${chunksToUpdate.length} notes starting from index ${currentIndex}`);
        }


        async function updateHeadingLevel(chunkId, headingLevel) {
            try {
                const response = await fetch(`${API_BASE}/chunks/${chunkId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        heading_level: headingLevel
                    })
                });

                if (!response.ok) {
                    throw new Error(`Failed to update heading level: ${response.status}`);
                }

                // Update local data
                const chunk = currentReviewChunks.find(c => c.id === chunkId);
                if (chunk) {
                    chunk.heading_level = headingLevel;
                    
                    // Update structure path based on heading level
                    let newStructurePath = chunk.structure_path;
                    
                    if (headingLevel === 'h1') {
                        // Extract the main section name and use the note content as heading
                        const sectionMatch = chunk.structure_path.match(/^(Section \d+)/);
                        if (sectionMatch) {
                            newStructurePath = `${sectionMatch[1]} > ${chunk.content.substring(0, 50)}${chunk.content.length > 50 ? '...' : ''}`;
                        }
                    } else if (headingLevel === 'h2') {
                        // Add as subheading
                        const sectionMatch = chunk.structure_path.match(/^(Section \d+)/);
                        if (sectionMatch) {
                            newStructurePath = `${sectionMatch[1]} > ${chunk.content.substring(0, 30)}${chunk.content.length > 30 ? '...' : ''}`;
                        }
                    } else if (headingLevel === 'h3') {
                        // Add as sub-subheading
                        const sectionMatch = chunk.structure_path.match(/^(Section \d+)/);
                        if (sectionMatch) {
                            newStructurePath = `${sectionMatch[1]} > ${chunk.content.substring(0, 20)}${chunk.content.length > 20 ? '...' : ''}`;
                        }
                    } else if (headingLevel === 'h4') {
                        // Add as sub-sub-subheading
                        const sectionMatch = chunk.structure_path.match(/^(Section \d+)/);
                        if (sectionMatch) {
                            newStructurePath = `${sectionMatch[1]} > ${chunk.content.substring(0, 15)}${chunk.content.length > 15 ? '...' : ''}`;
                        }
                    } else {
                        // For paragraph, keep original structure
                        newStructurePath = chunk.structure_path;
                    }
                    
                    // Update the structure path in the UI
                    chunk.structure_path = newStructurePath;
                    
                    // Update the structure path display
                    const structureElement = document.querySelector(`[data-chunk-id="${chunkId}"] .chunk-structure`);
                    if (structureElement) {
                        structureElement.textContent = newStructurePath;
                    }
                }

                console.log(`Note ${chunkId} heading level updated to ${headingLevel}`);

            } catch (error) {
                console.error('Error updating heading level:', error);
                alert(`Failed to update heading level: ${error.message}`);
            }
        }
        
        // Make functions globally available
        window.closeReviewInterface = closeReviewInterface;
        window.completeReview = completeReview;
        window.updateChunkContent = updateChunkContent;
        window.splitChunk = splitChunk;
        window.deleteChunk = deleteChunk;
        window.updateHeadingLevel = updateHeadingLevel;
        window.updateStructurePath = updateStructurePath;
    </script>
</body>
</html>